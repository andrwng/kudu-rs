// This file is generated. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]

use protobuf::CodedOutputStream;
use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(Clone,Default)]
pub struct ColumnSchemaPB {
    // message fields
    id: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<DataType>,
    is_key: ::std::option::Option<bool>,
    is_nullable: ::std::option::Option<bool>,
    read_default_value: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    write_default_value: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    encoding: ::std::option::Option<EncodingType>,
    compression: ::std::option::Option<CompressionType>,
    cfile_block_size: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ColumnSchemaPB {}

impl ColumnSchemaPB {
    pub fn new() -> ColumnSchemaPB {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ColumnSchemaPB {
        static mut instance: ::protobuf::lazy::Lazy<ColumnSchemaPB> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ColumnSchemaPB,
        };
        unsafe {
            instance.get(|| {
                ColumnSchemaPB {
                    id: ::std::option::Option::None,
                    name: ::protobuf::SingularField::none(),
                    field_type: ::std::option::Option::None,
                    is_key: ::std::option::Option::None,
                    is_nullable: ::std::option::Option::None,
                    read_default_value: ::protobuf::SingularField::none(),
                    write_default_value: ::protobuf::SingularField::none(),
                    encoding: ::std::option::Option::None,
                    compression: ::std::option::Option::None,
                    cfile_block_size: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    // required string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required .kudu.DataType type = 3;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DataType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> DataType {
        self.field_type.unwrap_or(DataType::UNKNOWN_DATA)
    }

    // optional bool is_key = 4;

    pub fn clear_is_key(&mut self) {
        self.is_key = ::std::option::Option::None;
    }

    pub fn has_is_key(&self) -> bool {
        self.is_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_key(&mut self, v: bool) {
        self.is_key = ::std::option::Option::Some(v);
    }

    pub fn get_is_key(&self) -> bool {
        self.is_key.unwrap_or(false)
    }

    // optional bool is_nullable = 5;

    pub fn clear_is_nullable(&mut self) {
        self.is_nullable = ::std::option::Option::None;
    }

    pub fn has_is_nullable(&self) -> bool {
        self.is_nullable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_nullable(&mut self, v: bool) {
        self.is_nullable = ::std::option::Option::Some(v);
    }

    pub fn get_is_nullable(&self) -> bool {
        self.is_nullable.unwrap_or(false)
    }

    // optional bytes read_default_value = 6;

    pub fn clear_read_default_value(&mut self) {
        self.read_default_value.clear();
    }

    pub fn has_read_default_value(&self) -> bool {
        self.read_default_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_default_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.read_default_value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_default_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.read_default_value.is_none() {
            self.read_default_value.set_default();
        };
        self.read_default_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_default_value(&mut self) -> ::std::vec::Vec<u8> {
        self.read_default_value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_read_default_value(&self) -> &[u8] {
        match self.read_default_value.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes write_default_value = 7;

    pub fn clear_write_default_value(&mut self) {
        self.write_default_value.clear();
    }

    pub fn has_write_default_value(&self) -> bool {
        self.write_default_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_write_default_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.write_default_value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_write_default_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.write_default_value.is_none() {
            self.write_default_value.set_default();
        };
        self.write_default_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_write_default_value(&mut self) -> ::std::vec::Vec<u8> {
        self.write_default_value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_write_default_value(&self) -> &[u8] {
        match self.write_default_value.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional .kudu.EncodingType encoding = 8;

    pub fn clear_encoding(&mut self) {
        self.encoding = ::std::option::Option::None;
    }

    pub fn has_encoding(&self) -> bool {
        self.encoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encoding(&mut self, v: EncodingType) {
        self.encoding = ::std::option::Option::Some(v);
    }

    pub fn get_encoding(&self) -> EncodingType {
        self.encoding.unwrap_or(EncodingType::AUTO_ENCODING)
    }

    // optional .kudu.CompressionType compression = 9;

    pub fn clear_compression(&mut self) {
        self.compression = ::std::option::Option::None;
    }

    pub fn has_compression(&self) -> bool {
        self.compression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compression(&mut self, v: CompressionType) {
        self.compression = ::std::option::Option::Some(v);
    }

    pub fn get_compression(&self) -> CompressionType {
        self.compression.unwrap_or(CompressionType::DEFAULT_COMPRESSION)
    }

    // optional int32 cfile_block_size = 10;

    pub fn clear_cfile_block_size(&mut self) {
        self.cfile_block_size = ::std::option::Option::None;
    }

    pub fn has_cfile_block_size(&self) -> bool {
        self.cfile_block_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cfile_block_size(&mut self, v: i32) {
        self.cfile_block_size = ::std::option::Option::Some(v);
    }

    pub fn get_cfile_block_size(&self) -> i32 {
        self.cfile_block_size.unwrap_or(0i32)
    }
}

impl ::protobuf::Message for ColumnSchemaPB {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        };
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.is_key = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.is_nullable = ::std::option::Option::Some(tmp);
                },
                6 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.read_default_value));
                },
                7 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.write_default_value));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.encoding = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.compression = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.cfile_block_size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(3, *value);
        };
        if self.is_key.is_some() {
            my_size += 2;
        };
        if self.is_nullable.is_some() {
            my_size += 2;
        };
        for value in self.read_default_value.iter() {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        for value in self.write_default_value.iter() {
            my_size += ::protobuf::rt::bytes_size(7, &value);
        };
        for value in self.encoding.iter() {
            my_size += ::protobuf::rt::enum_size(8, *value);
        };
        for value in self.compression.iter() {
            my_size += ::protobuf::rt::enum_size(9, *value);
        };
        for value in self.cfile_block_size.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, mut w: &mut ::std::io::Write) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            try!(w.write_uint32(1, v));
        };
        if let Some(v) = self.name.as_ref() {
            try!(w.write_string(2, &v));
        };
        if let Some(v) = self.field_type {
            try!(w.write_enum(3, v.value()));
        };
        if let Some(v) = self.is_key {
            try!(w.write_bool(4, v));
        };
        if let Some(v) = self.is_nullable {
            try!(w.write_bool(5, v));
        };
        if let Some(v) = self.read_default_value.as_ref() {
            try!(w.write_bytes(6, &v));
        };
        if let Some(v) = self.write_default_value.as_ref() {
            try!(w.write_bytes(7, &v));
        };
        if let Some(v) = self.encoding {
            try!(w.write_enum(8, v.value()));
        };
        if let Some(v) = self.compression {
            try!(w.write_enum(9, v.value()));
        };
        if let Some(v) = self.cfile_block_size {
            try!(w.write_int32(10, v));
        };
        try!(w.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ColumnSchemaPB>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ColumnSchemaPB {
    fn new() -> ColumnSchemaPB {
        ColumnSchemaPB::new()
    }

    fn descriptor_static(_: ::std::option::Option<ColumnSchemaPB>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "id",
                    ColumnSchemaPB::has_id,
                    ColumnSchemaPB::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    ColumnSchemaPB::has_name,
                    ColumnSchemaPB::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "type",
                    ColumnSchemaPB::has_field_type,
                    ColumnSchemaPB::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "is_key",
                    ColumnSchemaPB::has_is_key,
                    ColumnSchemaPB::get_is_key,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "is_nullable",
                    ColumnSchemaPB::has_is_nullable,
                    ColumnSchemaPB::get_is_nullable,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "read_default_value",
                    ColumnSchemaPB::has_read_default_value,
                    ColumnSchemaPB::get_read_default_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "write_default_value",
                    ColumnSchemaPB::has_write_default_value,
                    ColumnSchemaPB::get_write_default_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "encoding",
                    ColumnSchemaPB::has_encoding,
                    ColumnSchemaPB::get_encoding,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "compression",
                    ColumnSchemaPB::has_compression,
                    ColumnSchemaPB::get_compression,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "cfile_block_size",
                    ColumnSchemaPB::has_cfile_block_size,
                    ColumnSchemaPB::get_cfile_block_size,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ColumnSchemaPB>(
                    "ColumnSchemaPB",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ColumnSchemaPB {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_name();
        self.clear_field_type();
        self.clear_is_key();
        self.clear_is_nullable();
        self.clear_read_default_value();
        self.clear_write_default_value();
        self.clear_encoding();
        self.clear_compression();
        self.clear_cfile_block_size();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ColumnSchemaPB {
    fn eq(&self, other: &ColumnSchemaPB) -> bool {
        self.id == other.id &&
        self.name == other.name &&
        self.field_type == other.field_type &&
        self.is_key == other.is_key &&
        self.is_nullable == other.is_nullable &&
        self.read_default_value == other.read_default_value &&
        self.write_default_value == other.write_default_value &&
        self.encoding == other.encoding &&
        self.compression == other.compression &&
        self.cfile_block_size == other.cfile_block_size &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ColumnSchemaPB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SchemaPB {
    // message fields
    columns: ::protobuf::RepeatedField<ColumnSchemaPB>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SchemaPB {}

impl SchemaPB {
    pub fn new() -> SchemaPB {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SchemaPB {
        static mut instance: ::protobuf::lazy::Lazy<SchemaPB> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SchemaPB,
        };
        unsafe {
            instance.get(|| {
                SchemaPB {
                    columns: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .kudu.ColumnSchemaPB columns = 1;

    pub fn clear_columns(&mut self) {
        self.columns.clear();
    }

    // Param is passed by value, moved
    pub fn set_columns(&mut self, v: ::protobuf::RepeatedField<ColumnSchemaPB>) {
        self.columns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_columns(&mut self) -> &mut ::protobuf::RepeatedField<ColumnSchemaPB> {
        &mut self.columns
    }

    // Take field
    pub fn take_columns(&mut self) -> ::protobuf::RepeatedField<ColumnSchemaPB> {
        ::std::mem::replace(&mut self.columns, ::protobuf::RepeatedField::new())
    }

    pub fn get_columns(&self) -> &[ColumnSchemaPB] {
        &self.columns
    }
}

impl ::protobuf::Message for SchemaPB {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.columns));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.columns.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, mut w: &mut ::std::io::Write) -> ::protobuf::ProtobufResult<()> {
        for v in self.columns.iter() {
            try!(w.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(w.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(w));
        };
        try!(w.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SchemaPB>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SchemaPB {
    fn new() -> SchemaPB {
        SchemaPB::new()
    }

    fn descriptor_static(_: ::std::option::Option<SchemaPB>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "columns",
                    SchemaPB::get_columns,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SchemaPB>(
                    "SchemaPB",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SchemaPB {
    fn clear(&mut self) {
        self.clear_columns();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SchemaPB {
    fn eq(&self, other: &SchemaPB) -> bool {
        self.columns == other.columns &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SchemaPB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct HostPortPB {
    // message fields
    host: ::protobuf::SingularField<::std::string::String>,
    port: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for HostPortPB {}

impl HostPortPB {
    pub fn new() -> HostPortPB {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static HostPortPB {
        static mut instance: ::protobuf::lazy::Lazy<HostPortPB> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HostPortPB,
        };
        unsafe {
            instance.get(|| {
                HostPortPB {
                    host: ::protobuf::SingularField::none(),
                    port: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string host = 1;

    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host.set_default();
        };
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required uint32 port = 2;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port(&self) -> u32 {
        self.port.unwrap_or(0)
    }
}

impl ::protobuf::Message for HostPortPB {
    fn is_initialized(&self) -> bool {
        if self.host.is_none() {
            return false;
        };
        if self.port.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.host));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.host.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.port.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, mut w: &mut ::std::io::Write) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.host.as_ref() {
            try!(w.write_string(1, &v));
        };
        if let Some(v) = self.port {
            try!(w.write_uint32(2, v));
        };
        try!(w.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<HostPortPB>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for HostPortPB {
    fn new() -> HostPortPB {
        HostPortPB::new()
    }

    fn descriptor_static(_: ::std::option::Option<HostPortPB>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "host",
                    HostPortPB::has_host,
                    HostPortPB::get_host,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "port",
                    HostPortPB::has_port,
                    HostPortPB::get_port,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HostPortPB>(
                    "HostPortPB",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for HostPortPB {
    fn clear(&mut self) {
        self.clear_host();
        self.clear_port();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for HostPortPB {
    fn eq(&self, other: &HostPortPB) -> bool {
        self.host == other.host &&
        self.port == other.port &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for HostPortPB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct PartitionSchemaPB {
    // message fields
    hash_bucket_schemas: ::protobuf::RepeatedField<PartitionSchemaPB_HashBucketSchemaPB>,
    range_schema: ::protobuf::SingularPtrField<PartitionSchemaPB_RangeSchemaPB>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PartitionSchemaPB {}

impl PartitionSchemaPB {
    pub fn new() -> PartitionSchemaPB {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PartitionSchemaPB {
        static mut instance: ::protobuf::lazy::Lazy<PartitionSchemaPB> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PartitionSchemaPB,
        };
        unsafe {
            instance.get(|| {
                PartitionSchemaPB {
                    hash_bucket_schemas: ::protobuf::RepeatedField::new(),
                    range_schema: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .kudu.PartitionSchemaPB.HashBucketSchemaPB hash_bucket_schemas = 1;

    pub fn clear_hash_bucket_schemas(&mut self) {
        self.hash_bucket_schemas.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash_bucket_schemas(&mut self, v: ::protobuf::RepeatedField<PartitionSchemaPB_HashBucketSchemaPB>) {
        self.hash_bucket_schemas = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hash_bucket_schemas(&mut self) -> &mut ::protobuf::RepeatedField<PartitionSchemaPB_HashBucketSchemaPB> {
        &mut self.hash_bucket_schemas
    }

    // Take field
    pub fn take_hash_bucket_schemas(&mut self) -> ::protobuf::RepeatedField<PartitionSchemaPB_HashBucketSchemaPB> {
        ::std::mem::replace(&mut self.hash_bucket_schemas, ::protobuf::RepeatedField::new())
    }

    pub fn get_hash_bucket_schemas(&self) -> &[PartitionSchemaPB_HashBucketSchemaPB] {
        &self.hash_bucket_schemas
    }

    // optional .kudu.PartitionSchemaPB.RangeSchemaPB range_schema = 2;

    pub fn clear_range_schema(&mut self) {
        self.range_schema.clear();
    }

    pub fn has_range_schema(&self) -> bool {
        self.range_schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range_schema(&mut self, v: PartitionSchemaPB_RangeSchemaPB) {
        self.range_schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range_schema(&mut self) -> &mut PartitionSchemaPB_RangeSchemaPB {
        if self.range_schema.is_none() {
            self.range_schema.set_default();
        };
        self.range_schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_range_schema(&mut self) -> PartitionSchemaPB_RangeSchemaPB {
        self.range_schema.take().unwrap_or_else(|| PartitionSchemaPB_RangeSchemaPB::new())
    }

    pub fn get_range_schema(&self) -> &PartitionSchemaPB_RangeSchemaPB {
        self.range_schema.as_ref().unwrap_or_else(|| PartitionSchemaPB_RangeSchemaPB::default_instance())
    }
}

impl ::protobuf::Message for PartitionSchemaPB {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hash_bucket_schemas));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.range_schema));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.hash_bucket_schemas.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.range_schema.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, mut w: &mut ::std::io::Write) -> ::protobuf::ProtobufResult<()> {
        for v in self.hash_bucket_schemas.iter() {
            try!(w.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(w.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(w));
        };
        if let Some(v) = self.range_schema.as_ref() {
            try!(w.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(w.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(w));
        };
        try!(w.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<PartitionSchemaPB>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PartitionSchemaPB {
    fn new() -> PartitionSchemaPB {
        PartitionSchemaPB::new()
    }

    fn descriptor_static(_: ::std::option::Option<PartitionSchemaPB>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "hash_bucket_schemas",
                    PartitionSchemaPB::get_hash_bucket_schemas,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "range_schema",
                    PartitionSchemaPB::has_range_schema,
                    PartitionSchemaPB::get_range_schema,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PartitionSchemaPB>(
                    "PartitionSchemaPB",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PartitionSchemaPB {
    fn clear(&mut self) {
        self.clear_hash_bucket_schemas();
        self.clear_range_schema();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for PartitionSchemaPB {
    fn eq(&self, other: &PartitionSchemaPB) -> bool {
        self.hash_bucket_schemas == other.hash_bucket_schemas &&
        self.range_schema == other.range_schema &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for PartitionSchemaPB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct PartitionSchemaPB_ColumnIdentifierPB {
    // message oneof groups
    identifier: ::std::option::Option<PartitionSchemaPB_ColumnIdentifierPB_oneof_identifier>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PartitionSchemaPB_ColumnIdentifierPB {}

#[derive(Clone,PartialEq)]
pub enum PartitionSchemaPB_ColumnIdentifierPB_oneof_identifier {
    id(i32),
    name(::std::string::String),
}

impl PartitionSchemaPB_ColumnIdentifierPB {
    pub fn new() -> PartitionSchemaPB_ColumnIdentifierPB {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PartitionSchemaPB_ColumnIdentifierPB {
        static mut instance: ::protobuf::lazy::Lazy<PartitionSchemaPB_ColumnIdentifierPB> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PartitionSchemaPB_ColumnIdentifierPB,
        };
        unsafe {
            instance.get(|| {
                PartitionSchemaPB_ColumnIdentifierPB {
                    identifier: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 id = 1;

    pub fn clear_id(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(PartitionSchemaPB_ColumnIdentifierPB_oneof_identifier::id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.identifier = ::std::option::Option::Some(PartitionSchemaPB_ColumnIdentifierPB_oneof_identifier::id(v))
    }

    pub fn get_id(&self) -> i32 {
        match self.identifier {
            ::std::option::Option::Some(PartitionSchemaPB_ColumnIdentifierPB_oneof_identifier::id(v)) => v,
            _ => 0,
        }
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(PartitionSchemaPB_ColumnIdentifierPB_oneof_identifier::name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.identifier = ::std::option::Option::Some(PartitionSchemaPB_ColumnIdentifierPB_oneof_identifier::name(v))
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(PartitionSchemaPB_ColumnIdentifierPB_oneof_identifier::name(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(PartitionSchemaPB_ColumnIdentifierPB_oneof_identifier::name(::std::string::String::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(PartitionSchemaPB_ColumnIdentifierPB_oneof_identifier::name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        if self.has_name() {
            match self.identifier.take() {
                ::std::option::Option::Some(PartitionSchemaPB_ColumnIdentifierPB_oneof_identifier::name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_name(&self) -> &str {
        match self.identifier {
            ::std::option::Option::Some(PartitionSchemaPB_ColumnIdentifierPB_oneof_identifier::name(ref v)) => v,
            _ => "",
        }
    }
}

impl ::protobuf::Message for PartitionSchemaPB_ColumnIdentifierPB {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    self.identifier = ::std::option::Option::Some(PartitionSchemaPB_ColumnIdentifierPB_oneof_identifier::id(try!(is.read_int32())));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    self.identifier = ::std::option::Option::Some(PartitionSchemaPB_ColumnIdentifierPB_oneof_identifier::name(try!(is.read_string())));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.identifier {
            match v {
                &PartitionSchemaPB_ColumnIdentifierPB_oneof_identifier::id(v) => {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &PartitionSchemaPB_ColumnIdentifierPB_oneof_identifier::name(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, mut w: &mut ::std::io::Write) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.identifier {
            match v {
                &PartitionSchemaPB_ColumnIdentifierPB_oneof_identifier::id(v) => {
                    try!(w.write_int32(1, v));
                },
                &PartitionSchemaPB_ColumnIdentifierPB_oneof_identifier::name(ref v) => {
                    try!(w.write_string(2, v));
                },
            };
        };
        try!(w.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<PartitionSchemaPB_ColumnIdentifierPB>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PartitionSchemaPB_ColumnIdentifierPB {
    fn new() -> PartitionSchemaPB_ColumnIdentifierPB {
        PartitionSchemaPB_ColumnIdentifierPB::new()
    }

    fn descriptor_static(_: ::std::option::Option<PartitionSchemaPB_ColumnIdentifierPB>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "id",
                    PartitionSchemaPB_ColumnIdentifierPB::has_id,
                    PartitionSchemaPB_ColumnIdentifierPB::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    PartitionSchemaPB_ColumnIdentifierPB::has_name,
                    PartitionSchemaPB_ColumnIdentifierPB::get_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PartitionSchemaPB_ColumnIdentifierPB>(
                    "PartitionSchemaPB_ColumnIdentifierPB",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PartitionSchemaPB_ColumnIdentifierPB {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for PartitionSchemaPB_ColumnIdentifierPB {
    fn eq(&self, other: &PartitionSchemaPB_ColumnIdentifierPB) -> bool {
        self.identifier == other.identifier &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for PartitionSchemaPB_ColumnIdentifierPB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct PartitionSchemaPB_RangeSchemaPB {
    // message fields
    columns: ::protobuf::RepeatedField<PartitionSchemaPB_ColumnIdentifierPB>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PartitionSchemaPB_RangeSchemaPB {}

impl PartitionSchemaPB_RangeSchemaPB {
    pub fn new() -> PartitionSchemaPB_RangeSchemaPB {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PartitionSchemaPB_RangeSchemaPB {
        static mut instance: ::protobuf::lazy::Lazy<PartitionSchemaPB_RangeSchemaPB> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PartitionSchemaPB_RangeSchemaPB,
        };
        unsafe {
            instance.get(|| {
                PartitionSchemaPB_RangeSchemaPB {
                    columns: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .kudu.PartitionSchemaPB.ColumnIdentifierPB columns = 1;

    pub fn clear_columns(&mut self) {
        self.columns.clear();
    }

    // Param is passed by value, moved
    pub fn set_columns(&mut self, v: ::protobuf::RepeatedField<PartitionSchemaPB_ColumnIdentifierPB>) {
        self.columns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_columns(&mut self) -> &mut ::protobuf::RepeatedField<PartitionSchemaPB_ColumnIdentifierPB> {
        &mut self.columns
    }

    // Take field
    pub fn take_columns(&mut self) -> ::protobuf::RepeatedField<PartitionSchemaPB_ColumnIdentifierPB> {
        ::std::mem::replace(&mut self.columns, ::protobuf::RepeatedField::new())
    }

    pub fn get_columns(&self) -> &[PartitionSchemaPB_ColumnIdentifierPB] {
        &self.columns
    }
}

impl ::protobuf::Message for PartitionSchemaPB_RangeSchemaPB {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.columns));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.columns.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, mut w: &mut ::std::io::Write) -> ::protobuf::ProtobufResult<()> {
        for v in self.columns.iter() {
            try!(w.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(w.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(w));
        };
        try!(w.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<PartitionSchemaPB_RangeSchemaPB>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PartitionSchemaPB_RangeSchemaPB {
    fn new() -> PartitionSchemaPB_RangeSchemaPB {
        PartitionSchemaPB_RangeSchemaPB::new()
    }

    fn descriptor_static(_: ::std::option::Option<PartitionSchemaPB_RangeSchemaPB>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "columns",
                    PartitionSchemaPB_RangeSchemaPB::get_columns,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PartitionSchemaPB_RangeSchemaPB>(
                    "PartitionSchemaPB_RangeSchemaPB",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PartitionSchemaPB_RangeSchemaPB {
    fn clear(&mut self) {
        self.clear_columns();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for PartitionSchemaPB_RangeSchemaPB {
    fn eq(&self, other: &PartitionSchemaPB_RangeSchemaPB) -> bool {
        self.columns == other.columns &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for PartitionSchemaPB_RangeSchemaPB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct PartitionSchemaPB_HashBucketSchemaPB {
    // message fields
    columns: ::protobuf::RepeatedField<PartitionSchemaPB_ColumnIdentifierPB>,
    num_buckets: ::std::option::Option<i32>,
    seed: ::std::option::Option<u32>,
    hash_algorithm: ::std::option::Option<PartitionSchemaPB_HashBucketSchemaPB_HashAlgorithm>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PartitionSchemaPB_HashBucketSchemaPB {}

impl PartitionSchemaPB_HashBucketSchemaPB {
    pub fn new() -> PartitionSchemaPB_HashBucketSchemaPB {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PartitionSchemaPB_HashBucketSchemaPB {
        static mut instance: ::protobuf::lazy::Lazy<PartitionSchemaPB_HashBucketSchemaPB> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PartitionSchemaPB_HashBucketSchemaPB,
        };
        unsafe {
            instance.get(|| {
                PartitionSchemaPB_HashBucketSchemaPB {
                    columns: ::protobuf::RepeatedField::new(),
                    num_buckets: ::std::option::Option::None,
                    seed: ::std::option::Option::None,
                    hash_algorithm: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .kudu.PartitionSchemaPB.ColumnIdentifierPB columns = 1;

    pub fn clear_columns(&mut self) {
        self.columns.clear();
    }

    // Param is passed by value, moved
    pub fn set_columns(&mut self, v: ::protobuf::RepeatedField<PartitionSchemaPB_ColumnIdentifierPB>) {
        self.columns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_columns(&mut self) -> &mut ::protobuf::RepeatedField<PartitionSchemaPB_ColumnIdentifierPB> {
        &mut self.columns
    }

    // Take field
    pub fn take_columns(&mut self) -> ::protobuf::RepeatedField<PartitionSchemaPB_ColumnIdentifierPB> {
        ::std::mem::replace(&mut self.columns, ::protobuf::RepeatedField::new())
    }

    pub fn get_columns(&self) -> &[PartitionSchemaPB_ColumnIdentifierPB] {
        &self.columns
    }

    // required int32 num_buckets = 2;

    pub fn clear_num_buckets(&mut self) {
        self.num_buckets = ::std::option::Option::None;
    }

    pub fn has_num_buckets(&self) -> bool {
        self.num_buckets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_buckets(&mut self, v: i32) {
        self.num_buckets = ::std::option::Option::Some(v);
    }

    pub fn get_num_buckets(&self) -> i32 {
        self.num_buckets.unwrap_or(0)
    }

    // optional uint32 seed = 3;

    pub fn clear_seed(&mut self) {
        self.seed = ::std::option::Option::None;
    }

    pub fn has_seed(&self) -> bool {
        self.seed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seed(&mut self, v: u32) {
        self.seed = ::std::option::Option::Some(v);
    }

    pub fn get_seed(&self) -> u32 {
        self.seed.unwrap_or(0)
    }

    // optional .kudu.PartitionSchemaPB.HashBucketSchemaPB.HashAlgorithm hash_algorithm = 4;

    pub fn clear_hash_algorithm(&mut self) {
        self.hash_algorithm = ::std::option::Option::None;
    }

    pub fn has_hash_algorithm(&self) -> bool {
        self.hash_algorithm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash_algorithm(&mut self, v: PartitionSchemaPB_HashBucketSchemaPB_HashAlgorithm) {
        self.hash_algorithm = ::std::option::Option::Some(v);
    }

    pub fn get_hash_algorithm(&self) -> PartitionSchemaPB_HashBucketSchemaPB_HashAlgorithm {
        self.hash_algorithm.unwrap_or(PartitionSchemaPB_HashBucketSchemaPB_HashAlgorithm::UNKNOWN)
    }
}

impl ::protobuf::Message for PartitionSchemaPB_HashBucketSchemaPB {
    fn is_initialized(&self) -> bool {
        if self.num_buckets.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.columns));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.num_buckets = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.seed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.hash_algorithm = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.columns.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.num_buckets.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.seed.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.hash_algorithm.iter() {
            my_size += ::protobuf::rt::enum_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, mut w: &mut ::std::io::Write) -> ::protobuf::ProtobufResult<()> {
        for v in self.columns.iter() {
            try!(w.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(w.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(w));
        };
        if let Some(v) = self.num_buckets {
            try!(w.write_int32(2, v));
        };
        if let Some(v) = self.seed {
            try!(w.write_uint32(3, v));
        };
        if let Some(v) = self.hash_algorithm {
            try!(w.write_enum(4, v.value()));
        };
        try!(w.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<PartitionSchemaPB_HashBucketSchemaPB>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PartitionSchemaPB_HashBucketSchemaPB {
    fn new() -> PartitionSchemaPB_HashBucketSchemaPB {
        PartitionSchemaPB_HashBucketSchemaPB::new()
    }

    fn descriptor_static(_: ::std::option::Option<PartitionSchemaPB_HashBucketSchemaPB>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "columns",
                    PartitionSchemaPB_HashBucketSchemaPB::get_columns,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "num_buckets",
                    PartitionSchemaPB_HashBucketSchemaPB::has_num_buckets,
                    PartitionSchemaPB_HashBucketSchemaPB::get_num_buckets,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "seed",
                    PartitionSchemaPB_HashBucketSchemaPB::has_seed,
                    PartitionSchemaPB_HashBucketSchemaPB::get_seed,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "hash_algorithm",
                    PartitionSchemaPB_HashBucketSchemaPB::has_hash_algorithm,
                    PartitionSchemaPB_HashBucketSchemaPB::get_hash_algorithm,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PartitionSchemaPB_HashBucketSchemaPB>(
                    "PartitionSchemaPB_HashBucketSchemaPB",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PartitionSchemaPB_HashBucketSchemaPB {
    fn clear(&mut self) {
        self.clear_columns();
        self.clear_num_buckets();
        self.clear_seed();
        self.clear_hash_algorithm();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for PartitionSchemaPB_HashBucketSchemaPB {
    fn eq(&self, other: &PartitionSchemaPB_HashBucketSchemaPB) -> bool {
        self.columns == other.columns &&
        self.num_buckets == other.num_buckets &&
        self.seed == other.seed &&
        self.hash_algorithm == other.hash_algorithm &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for PartitionSchemaPB_HashBucketSchemaPB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PartitionSchemaPB_HashBucketSchemaPB_HashAlgorithm {
    UNKNOWN = 0,
    MURMUR_HASH_2 = 1,
}

impl ::protobuf::ProtobufEnum for PartitionSchemaPB_HashBucketSchemaPB_HashAlgorithm {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartitionSchemaPB_HashBucketSchemaPB_HashAlgorithm> {
        match value {
            0 => ::std::option::Option::Some(PartitionSchemaPB_HashBucketSchemaPB_HashAlgorithm::UNKNOWN),
            1 => ::std::option::Option::Some(PartitionSchemaPB_HashBucketSchemaPB_HashAlgorithm::MURMUR_HASH_2),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PartitionSchemaPB_HashBucketSchemaPB_HashAlgorithm] = &[
            PartitionSchemaPB_HashBucketSchemaPB_HashAlgorithm::UNKNOWN,
            PartitionSchemaPB_HashBucketSchemaPB_HashAlgorithm::MURMUR_HASH_2,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<PartitionSchemaPB_HashBucketSchemaPB_HashAlgorithm>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PartitionSchemaPB_HashBucketSchemaPB_HashAlgorithm", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PartitionSchemaPB_HashBucketSchemaPB_HashAlgorithm {
}

#[derive(Clone,Default)]
pub struct PartitionPB {
    // message fields
    hash_buckets: ::std::vec::Vec<i32>,
    partition_key_start: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    partition_key_end: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PartitionPB {}

impl PartitionPB {
    pub fn new() -> PartitionPB {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PartitionPB {
        static mut instance: ::protobuf::lazy::Lazy<PartitionPB> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PartitionPB,
        };
        unsafe {
            instance.get(|| {
                PartitionPB {
                    hash_buckets: ::std::vec::Vec::new(),
                    partition_key_start: ::protobuf::SingularField::none(),
                    partition_key_end: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated int32 hash_buckets = 1;

    pub fn clear_hash_buckets(&mut self) {
        self.hash_buckets.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash_buckets(&mut self, v: ::std::vec::Vec<i32>) {
        self.hash_buckets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hash_buckets(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.hash_buckets
    }

    // Take field
    pub fn take_hash_buckets(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.hash_buckets, ::std::vec::Vec::new())
    }

    pub fn get_hash_buckets(&self) -> &[i32] {
        &self.hash_buckets
    }

    // optional bytes partition_key_start = 2;

    pub fn clear_partition_key_start(&mut self) {
        self.partition_key_start.clear();
    }

    pub fn has_partition_key_start(&self) -> bool {
        self.partition_key_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition_key_start(&mut self, v: ::std::vec::Vec<u8>) {
        self.partition_key_start = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_partition_key_start(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.partition_key_start.is_none() {
            self.partition_key_start.set_default();
        };
        self.partition_key_start.as_mut().unwrap()
    }

    // Take field
    pub fn take_partition_key_start(&mut self) -> ::std::vec::Vec<u8> {
        self.partition_key_start.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_partition_key_start(&self) -> &[u8] {
        match self.partition_key_start.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes partition_key_end = 3;

    pub fn clear_partition_key_end(&mut self) {
        self.partition_key_end.clear();
    }

    pub fn has_partition_key_end(&self) -> bool {
        self.partition_key_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition_key_end(&mut self, v: ::std::vec::Vec<u8>) {
        self.partition_key_end = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_partition_key_end(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.partition_key_end.is_none() {
            self.partition_key_end.set_default();
        };
        self.partition_key_end.as_mut().unwrap()
    }

    // Take field
    pub fn take_partition_key_end(&mut self) -> ::std::vec::Vec<u8> {
        self.partition_key_end.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_partition_key_end(&self) -> &[u8] {
        match self.partition_key_end.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for PartitionPB {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.hash_buckets));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.partition_key_start));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.partition_key_end));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash_buckets.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(1, &self.hash_buckets);
        };
        for value in self.partition_key_start.iter() {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        for value in self.partition_key_end.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, mut w: &mut ::std::io::Write) -> ::protobuf::ProtobufResult<()> {
        if !self.hash_buckets.is_empty() {
            try!(w.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            // TODO: Data size is computed again, it should be cached
            try!(w.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.hash_buckets)));
            for v in self.hash_buckets.iter() {
                try!(w.write_int32_no_tag(*v));
            };
        };
        if let Some(v) = self.partition_key_start.as_ref() {
            try!(w.write_bytes(2, &v));
        };
        if let Some(v) = self.partition_key_end.as_ref() {
            try!(w.write_bytes(3, &v));
        };
        try!(w.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<PartitionPB>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PartitionPB {
    fn new() -> PartitionPB {
        PartitionPB::new()
    }

    fn descriptor_static(_: ::std::option::Option<PartitionPB>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_i32_accessor(
                    "hash_buckets",
                    PartitionPB::get_hash_buckets,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "partition_key_start",
                    PartitionPB::has_partition_key_start,
                    PartitionPB::get_partition_key_start,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "partition_key_end",
                    PartitionPB::has_partition_key_end,
                    PartitionPB::get_partition_key_end,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PartitionPB>(
                    "PartitionPB",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PartitionPB {
    fn clear(&mut self) {
        self.clear_hash_buckets();
        self.clear_partition_key_start();
        self.clear_partition_key_end();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for PartitionPB {
    fn eq(&self, other: &PartitionPB) -> bool {
        self.hash_buckets == other.hash_buckets &&
        self.partition_key_start == other.partition_key_start &&
        self.partition_key_end == other.partition_key_end &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for PartitionPB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ColumnPredicatePB {
    // message fields
    column: ::protobuf::SingularField<::std::string::String>,
    // message oneof groups
    predicate: ::std::option::Option<ColumnPredicatePB_oneof_predicate>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ColumnPredicatePB {}

#[derive(Clone,PartialEq)]
pub enum ColumnPredicatePB_oneof_predicate {
    range(ColumnPredicatePB_Range),
    equality(ColumnPredicatePB_Equality),
    is_not_null(ColumnPredicatePB_IsNotNull),
}

impl ColumnPredicatePB {
    pub fn new() -> ColumnPredicatePB {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ColumnPredicatePB {
        static mut instance: ::protobuf::lazy::Lazy<ColumnPredicatePB> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ColumnPredicatePB,
        };
        unsafe {
            instance.get(|| {
                ColumnPredicatePB {
                    column: ::protobuf::SingularField::none(),
                    predicate: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional string column = 1;

    pub fn clear_column(&mut self) {
        self.column.clear();
    }

    pub fn has_column(&self) -> bool {
        self.column.is_some()
    }

    // Param is passed by value, moved
    pub fn set_column(&mut self, v: ::std::string::String) {
        self.column = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_column(&mut self) -> &mut ::std::string::String {
        if self.column.is_none() {
            self.column.set_default();
        };
        self.column.as_mut().unwrap()
    }

    // Take field
    pub fn take_column(&mut self) -> ::std::string::String {
        self.column.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_column(&self) -> &str {
        match self.column.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .kudu.ColumnPredicatePB.Range range = 2;

    pub fn clear_range(&mut self) {
        self.predicate = ::std::option::Option::None;
    }

    pub fn has_range(&self) -> bool {
        match self.predicate {
            ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: ColumnPredicatePB_Range) {
        self.predicate = ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::range(v))
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range(&mut self) -> &mut ColumnPredicatePB_Range {
        if let ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::range(_)) = self.predicate {
        } else {
            self.predicate = ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::range(ColumnPredicatePB_Range::new()));
        }
        match self.predicate {
            ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_range(&mut self) -> ColumnPredicatePB_Range {
        if self.has_range() {
            match self.predicate.take() {
                ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::range(v)) => v,
                _ => panic!(),
            }
        } else {
            ColumnPredicatePB_Range::new()
        }
    }

    pub fn get_range(&self) -> &ColumnPredicatePB_Range {
        match self.predicate {
            ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::range(ref v)) => v,
            _ => ColumnPredicatePB_Range::default_instance(),
        }
    }

    // optional .kudu.ColumnPredicatePB.Equality equality = 3;

    pub fn clear_equality(&mut self) {
        self.predicate = ::std::option::Option::None;
    }

    pub fn has_equality(&self) -> bool {
        match self.predicate {
            ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::equality(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_equality(&mut self, v: ColumnPredicatePB_Equality) {
        self.predicate = ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::equality(v))
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_equality(&mut self) -> &mut ColumnPredicatePB_Equality {
        if let ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::equality(_)) = self.predicate {
        } else {
            self.predicate = ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::equality(ColumnPredicatePB_Equality::new()));
        }
        match self.predicate {
            ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::equality(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_equality(&mut self) -> ColumnPredicatePB_Equality {
        if self.has_equality() {
            match self.predicate.take() {
                ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::equality(v)) => v,
                _ => panic!(),
            }
        } else {
            ColumnPredicatePB_Equality::new()
        }
    }

    pub fn get_equality(&self) -> &ColumnPredicatePB_Equality {
        match self.predicate {
            ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::equality(ref v)) => v,
            _ => ColumnPredicatePB_Equality::default_instance(),
        }
    }

    // optional .kudu.ColumnPredicatePB.IsNotNull is_not_null = 4;

    pub fn clear_is_not_null(&mut self) {
        self.predicate = ::std::option::Option::None;
    }

    pub fn has_is_not_null(&self) -> bool {
        match self.predicate {
            ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::is_not_null(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_is_not_null(&mut self, v: ColumnPredicatePB_IsNotNull) {
        self.predicate = ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::is_not_null(v))
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_is_not_null(&mut self) -> &mut ColumnPredicatePB_IsNotNull {
        if let ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::is_not_null(_)) = self.predicate {
        } else {
            self.predicate = ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::is_not_null(ColumnPredicatePB_IsNotNull::new()));
        }
        match self.predicate {
            ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::is_not_null(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_is_not_null(&mut self) -> ColumnPredicatePB_IsNotNull {
        if self.has_is_not_null() {
            match self.predicate.take() {
                ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::is_not_null(v)) => v,
                _ => panic!(),
            }
        } else {
            ColumnPredicatePB_IsNotNull::new()
        }
    }

    pub fn get_is_not_null(&self) -> &ColumnPredicatePB_IsNotNull {
        match self.predicate {
            ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::is_not_null(ref v)) => v,
            _ => ColumnPredicatePB_IsNotNull::default_instance(),
        }
    }
}

impl ::protobuf::Message for ColumnPredicatePB {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.column));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    self.predicate = ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::range(try!(is.read_message())));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    self.predicate = ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::equality(try!(is.read_message())));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    self.predicate = ::std::option::Option::Some(ColumnPredicatePB_oneof_predicate::is_not_null(try!(is.read_message())));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.column.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let ::std::option::Option::Some(ref v) = self.predicate {
            match v {
                &ColumnPredicatePB_oneof_predicate::range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ColumnPredicatePB_oneof_predicate::equality(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ColumnPredicatePB_oneof_predicate::is_not_null(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, mut w: &mut ::std::io::Write) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.column.as_ref() {
            try!(w.write_string(1, &v));
        };
        if let ::std::option::Option::Some(ref v) = self.predicate {
            match v {
                &ColumnPredicatePB_oneof_predicate::range(ref v) => {
                    try!(w.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
                    try!(w.write_raw_varint32(v.get_cached_size()));
                    try!(v.write_to_with_cached_sizes(w));
                },
                &ColumnPredicatePB_oneof_predicate::equality(ref v) => {
                    try!(w.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
                    try!(w.write_raw_varint32(v.get_cached_size()));
                    try!(v.write_to_with_cached_sizes(w));
                },
                &ColumnPredicatePB_oneof_predicate::is_not_null(ref v) => {
                    try!(w.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
                    try!(w.write_raw_varint32(v.get_cached_size()));
                    try!(v.write_to_with_cached_sizes(w));
                },
            };
        };
        try!(w.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ColumnPredicatePB>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ColumnPredicatePB {
    fn new() -> ColumnPredicatePB {
        ColumnPredicatePB::new()
    }

    fn descriptor_static(_: ::std::option::Option<ColumnPredicatePB>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "column",
                    ColumnPredicatePB::has_column,
                    ColumnPredicatePB::get_column,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "range",
                    ColumnPredicatePB::has_range,
                    ColumnPredicatePB::get_range,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "equality",
                    ColumnPredicatePB::has_equality,
                    ColumnPredicatePB::get_equality,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "is_not_null",
                    ColumnPredicatePB::has_is_not_null,
                    ColumnPredicatePB::get_is_not_null,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ColumnPredicatePB>(
                    "ColumnPredicatePB",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ColumnPredicatePB {
    fn clear(&mut self) {
        self.clear_column();
        self.clear_range();
        self.clear_equality();
        self.clear_is_not_null();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ColumnPredicatePB {
    fn eq(&self, other: &ColumnPredicatePB) -> bool {
        self.column == other.column &&
        self.predicate == other.predicate &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ColumnPredicatePB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ColumnPredicatePB_Range {
    // message fields
    lower: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    upper: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ColumnPredicatePB_Range {}

impl ColumnPredicatePB_Range {
    pub fn new() -> ColumnPredicatePB_Range {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ColumnPredicatePB_Range {
        static mut instance: ::protobuf::lazy::Lazy<ColumnPredicatePB_Range> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ColumnPredicatePB_Range,
        };
        unsafe {
            instance.get(|| {
                ColumnPredicatePB_Range {
                    lower: ::protobuf::SingularField::none(),
                    upper: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional bytes lower = 1;

    pub fn clear_lower(&mut self) {
        self.lower.clear();
    }

    pub fn has_lower(&self) -> bool {
        self.lower.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lower(&mut self, v: ::std::vec::Vec<u8>) {
        self.lower = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lower(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.lower.is_none() {
            self.lower.set_default();
        };
        self.lower.as_mut().unwrap()
    }

    // Take field
    pub fn take_lower(&mut self) -> ::std::vec::Vec<u8> {
        self.lower.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_lower(&self) -> &[u8] {
        match self.lower.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes upper = 2;

    pub fn clear_upper(&mut self) {
        self.upper.clear();
    }

    pub fn has_upper(&self) -> bool {
        self.upper.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upper(&mut self, v: ::std::vec::Vec<u8>) {
        self.upper = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upper(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.upper.is_none() {
            self.upper.set_default();
        };
        self.upper.as_mut().unwrap()
    }

    // Take field
    pub fn take_upper(&mut self) -> ::std::vec::Vec<u8> {
        self.upper.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_upper(&self) -> &[u8] {
        match self.upper.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for ColumnPredicatePB_Range {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.lower));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.upper));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.lower.iter() {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        for value in self.upper.iter() {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, mut w: &mut ::std::io::Write) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.lower.as_ref() {
            try!(w.write_bytes(1, &v));
        };
        if let Some(v) = self.upper.as_ref() {
            try!(w.write_bytes(2, &v));
        };
        try!(w.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ColumnPredicatePB_Range>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ColumnPredicatePB_Range {
    fn new() -> ColumnPredicatePB_Range {
        ColumnPredicatePB_Range::new()
    }

    fn descriptor_static(_: ::std::option::Option<ColumnPredicatePB_Range>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "lower",
                    ColumnPredicatePB_Range::has_lower,
                    ColumnPredicatePB_Range::get_lower,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "upper",
                    ColumnPredicatePB_Range::has_upper,
                    ColumnPredicatePB_Range::get_upper,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ColumnPredicatePB_Range>(
                    "ColumnPredicatePB_Range",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ColumnPredicatePB_Range {
    fn clear(&mut self) {
        self.clear_lower();
        self.clear_upper();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ColumnPredicatePB_Range {
    fn eq(&self, other: &ColumnPredicatePB_Range) -> bool {
        self.lower == other.lower &&
        self.upper == other.upper &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ColumnPredicatePB_Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ColumnPredicatePB_Equality {
    // message fields
    value: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ColumnPredicatePB_Equality {}

impl ColumnPredicatePB_Equality {
    pub fn new() -> ColumnPredicatePB_Equality {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ColumnPredicatePB_Equality {
        static mut instance: ::protobuf::lazy::Lazy<ColumnPredicatePB_Equality> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ColumnPredicatePB_Equality,
        };
        unsafe {
            instance.get(|| {
                ColumnPredicatePB_Equality {
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional bytes value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        self.value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[u8] {
        match self.value.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for ColumnPredicatePB_Equality {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.value));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.value.iter() {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, mut w: &mut ::std::io::Write) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value.as_ref() {
            try!(w.write_bytes(1, &v));
        };
        try!(w.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ColumnPredicatePB_Equality>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ColumnPredicatePB_Equality {
    fn new() -> ColumnPredicatePB_Equality {
        ColumnPredicatePB_Equality::new()
    }

    fn descriptor_static(_: ::std::option::Option<ColumnPredicatePB_Equality>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "value",
                    ColumnPredicatePB_Equality::has_value,
                    ColumnPredicatePB_Equality::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ColumnPredicatePB_Equality>(
                    "ColumnPredicatePB_Equality",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ColumnPredicatePB_Equality {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ColumnPredicatePB_Equality {
    fn eq(&self, other: &ColumnPredicatePB_Equality) -> bool {
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ColumnPredicatePB_Equality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ColumnPredicatePB_IsNotNull {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ColumnPredicatePB_IsNotNull {}

impl ColumnPredicatePB_IsNotNull {
    pub fn new() -> ColumnPredicatePB_IsNotNull {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ColumnPredicatePB_IsNotNull {
        static mut instance: ::protobuf::lazy::Lazy<ColumnPredicatePB_IsNotNull> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ColumnPredicatePB_IsNotNull,
        };
        unsafe {
            instance.get(|| {
                ColumnPredicatePB_IsNotNull {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for ColumnPredicatePB_IsNotNull {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, mut w: &mut ::std::io::Write) -> ::protobuf::ProtobufResult<()> {
        try!(w.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ColumnPredicatePB_IsNotNull>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ColumnPredicatePB_IsNotNull {
    fn new() -> ColumnPredicatePB_IsNotNull {
        ColumnPredicatePB_IsNotNull::new()
    }

    fn descriptor_static(_: ::std::option::Option<ColumnPredicatePB_IsNotNull>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ColumnPredicatePB_IsNotNull>(
                    "ColumnPredicatePB_IsNotNull",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ColumnPredicatePB_IsNotNull {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ColumnPredicatePB_IsNotNull {
    fn eq(&self, other: &ColumnPredicatePB_IsNotNull) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ColumnPredicatePB_IsNotNull {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DataType {
    UNKNOWN_DATA = 999,
    UINT8 = 0,
    INT8 = 1,
    UINT16 = 2,
    INT16 = 3,
    UINT32 = 4,
    INT32 = 5,
    UINT64 = 6,
    INT64 = 7,
    STRING = 8,
    BOOL = 9,
    FLOAT = 10,
    DOUBLE = 11,
    BINARY = 12,
    TIMESTAMP = 13,
}

impl ::protobuf::ProtobufEnum for DataType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataType> {
        match value {
            999 => ::std::option::Option::Some(DataType::UNKNOWN_DATA),
            0 => ::std::option::Option::Some(DataType::UINT8),
            1 => ::std::option::Option::Some(DataType::INT8),
            2 => ::std::option::Option::Some(DataType::UINT16),
            3 => ::std::option::Option::Some(DataType::INT16),
            4 => ::std::option::Option::Some(DataType::UINT32),
            5 => ::std::option::Option::Some(DataType::INT32),
            6 => ::std::option::Option::Some(DataType::UINT64),
            7 => ::std::option::Option::Some(DataType::INT64),
            8 => ::std::option::Option::Some(DataType::STRING),
            9 => ::std::option::Option::Some(DataType::BOOL),
            10 => ::std::option::Option::Some(DataType::FLOAT),
            11 => ::std::option::Option::Some(DataType::DOUBLE),
            12 => ::std::option::Option::Some(DataType::BINARY),
            13 => ::std::option::Option::Some(DataType::TIMESTAMP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataType] = &[
            DataType::UNKNOWN_DATA,
            DataType::UINT8,
            DataType::INT8,
            DataType::UINT16,
            DataType::INT16,
            DataType::UINT32,
            DataType::INT32,
            DataType::UINT64,
            DataType::INT64,
            DataType::STRING,
            DataType::BOOL,
            DataType::FLOAT,
            DataType::DOUBLE,
            DataType::BINARY,
            DataType::TIMESTAMP,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<DataType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DataType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DataType {
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EncodingType {
    UNKNOWN_ENCODING = 999,
    AUTO_ENCODING = 0,
    PLAIN_ENCODING = 1,
    PREFIX_ENCODING = 2,
    GROUP_VARINT = 3,
    RLE = 4,
    DICT_ENCODING = 5,
    BIT_SHUFFLE = 6,
}

impl ::protobuf::ProtobufEnum for EncodingType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EncodingType> {
        match value {
            999 => ::std::option::Option::Some(EncodingType::UNKNOWN_ENCODING),
            0 => ::std::option::Option::Some(EncodingType::AUTO_ENCODING),
            1 => ::std::option::Option::Some(EncodingType::PLAIN_ENCODING),
            2 => ::std::option::Option::Some(EncodingType::PREFIX_ENCODING),
            3 => ::std::option::Option::Some(EncodingType::GROUP_VARINT),
            4 => ::std::option::Option::Some(EncodingType::RLE),
            5 => ::std::option::Option::Some(EncodingType::DICT_ENCODING),
            6 => ::std::option::Option::Some(EncodingType::BIT_SHUFFLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EncodingType] = &[
            EncodingType::UNKNOWN_ENCODING,
            EncodingType::AUTO_ENCODING,
            EncodingType::PLAIN_ENCODING,
            EncodingType::PREFIX_ENCODING,
            EncodingType::GROUP_VARINT,
            EncodingType::RLE,
            EncodingType::DICT_ENCODING,
            EncodingType::BIT_SHUFFLE,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EncodingType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EncodingType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EncodingType {
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CompressionType {
    UNKNOWN_COMPRESSION = 999,
    DEFAULT_COMPRESSION = 0,
    NO_COMPRESSION = 1,
    SNAPPY = 2,
    LZ4 = 3,
    ZLIB = 4,
}

impl ::protobuf::ProtobufEnum for CompressionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CompressionType> {
        match value {
            999 => ::std::option::Option::Some(CompressionType::UNKNOWN_COMPRESSION),
            0 => ::std::option::Option::Some(CompressionType::DEFAULT_COMPRESSION),
            1 => ::std::option::Option::Some(CompressionType::NO_COMPRESSION),
            2 => ::std::option::Option::Some(CompressionType::SNAPPY),
            3 => ::std::option::Option::Some(CompressionType::LZ4),
            4 => ::std::option::Option::Some(CompressionType::ZLIB),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CompressionType] = &[
            CompressionType::UNKNOWN_COMPRESSION,
            CompressionType::DEFAULT_COMPRESSION,
            CompressionType::NO_COMPRESSION,
            CompressionType::SNAPPY,
            CompressionType::LZ4,
            CompressionType::ZLIB,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<CompressionType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CompressionType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CompressionType {
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExternalConsistencyMode {
    UNKNOWN_EXTERNAL_CONSISTENCY_MODE = 0,
    CLIENT_PROPAGATED = 1,
    COMMIT_WAIT = 2,
}

impl ::protobuf::ProtobufEnum for ExternalConsistencyMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExternalConsistencyMode> {
        match value {
            0 => ::std::option::Option::Some(ExternalConsistencyMode::UNKNOWN_EXTERNAL_CONSISTENCY_MODE),
            1 => ::std::option::Option::Some(ExternalConsistencyMode::CLIENT_PROPAGATED),
            2 => ::std::option::Option::Some(ExternalConsistencyMode::COMMIT_WAIT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExternalConsistencyMode] = &[
            ExternalConsistencyMode::UNKNOWN_EXTERNAL_CONSISTENCY_MODE,
            ExternalConsistencyMode::CLIENT_PROPAGATED,
            ExternalConsistencyMode::COMMIT_WAIT,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<ExternalConsistencyMode>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ExternalConsistencyMode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ExternalConsistencyMode {
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ReadMode {
    UNKNOWN_READ_MODE = 0,
    READ_LATEST = 1,
    READ_AT_SNAPSHOT = 2,
}

impl ::protobuf::ProtobufEnum for ReadMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReadMode> {
        match value {
            0 => ::std::option::Option::Some(ReadMode::UNKNOWN_READ_MODE),
            1 => ::std::option::Option::Some(ReadMode::READ_LATEST),
            2 => ::std::option::Option::Some(ReadMode::READ_AT_SNAPSHOT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReadMode] = &[
            ReadMode::UNKNOWN_READ_MODE,
            ReadMode::READ_LATEST,
            ReadMode::READ_AT_SNAPSHOT,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<ReadMode>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ReadMode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ReadMode {
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OrderMode {
    UNKNOWN_ORDER_MODE = 0,
    UNORDERED = 1,
    ORDERED = 2,
}

impl ::protobuf::ProtobufEnum for OrderMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OrderMode> {
        match value {
            0 => ::std::option::Option::Some(OrderMode::UNKNOWN_ORDER_MODE),
            1 => ::std::option::Option::Some(OrderMode::UNORDERED),
            2 => ::std::option::Option::Some(OrderMode::ORDERED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OrderMode] = &[
            OrderMode::UNKNOWN_ORDER_MODE,
            OrderMode::UNORDERED,
            OrderMode::ORDERED,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<OrderMode>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("OrderMode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OrderMode {
}

static file_descriptor_proto_data: &'static [u8] = &[
    0x0a, 0x18, 0x6b, 0x75, 0x64, 0x75, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x63, 0x6f,
    0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x04, 0x6b, 0x75, 0x64, 0x75,
    0x22, 0xc7, 0x02, 0x0a, 0x0e, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d,
    0x61, 0x50, 0x42, 0x12, 0x0a, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x09, 0x12, 0x1c, 0x0a,
    0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x0e, 0x2e, 0x6b, 0x75,
    0x64, 0x75, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x54, 0x79, 0x70, 0x65, 0x12, 0x15, 0x0a, 0x06, 0x69,
    0x73, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c,
    0x73, 0x65, 0x12, 0x1a, 0x0a, 0x0b, 0x69, 0x73, 0x5f, 0x6e, 0x75, 0x6c, 0x6c, 0x61, 0x62, 0x6c,
    0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x12, 0x1a,
    0x0a, 0x12, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x76,
    0x61, 0x6c, 0x75, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x1b, 0x0a, 0x13, 0x77, 0x72,
    0x69, 0x74, 0x65, 0x5f, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x75,
    0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x33, 0x0a, 0x08, 0x65, 0x6e, 0x63, 0x6f, 0x64,
    0x69, 0x6e, 0x67, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x6b, 0x75, 0x64, 0x75,
    0x2e, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x0d, 0x41,
    0x55, 0x54, 0x4f, 0x5f, 0x45, 0x4e, 0x43, 0x4f, 0x44, 0x49, 0x4e, 0x47, 0x12, 0x3f, 0x0a, 0x0b,
    0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x09, 0x20, 0x01, 0x28,
    0x0e, 0x32, 0x15, 0x2e, 0x6b, 0x75, 0x64, 0x75, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73,
    0x73, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x13, 0x44, 0x45, 0x46, 0x41, 0x55, 0x4c,
    0x54, 0x5f, 0x43, 0x4f, 0x4d, 0x50, 0x52, 0x45, 0x53, 0x53, 0x49, 0x4f, 0x4e, 0x12, 0x1b, 0x0a,
    0x10, 0x63, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x73, 0x69, 0x7a,
    0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x30, 0x22, 0x31, 0x0a, 0x08, 0x53, 0x63,
    0x68, 0x65, 0x6d, 0x61, 0x50, 0x42, 0x12, 0x25, 0x0a, 0x07, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e,
    0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6b, 0x75, 0x64, 0x75, 0x2e, 0x43,
    0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x50, 0x42, 0x22, 0x28, 0x0a,
    0x0a, 0x48, 0x6f, 0x73, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x50, 0x42, 0x12, 0x0c, 0x0a, 0x04, 0x68,
    0x6f, 0x73, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0c, 0x0a, 0x04, 0x70, 0x6f, 0x72,
    0x74, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0d, 0x22, 0xa3, 0x04, 0x0a, 0x11, 0x50, 0x61, 0x72, 0x74,
    0x69, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x50, 0x42, 0x12, 0x47, 0x0a,
    0x13, 0x68, 0x61, 0x73, 0x68, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x73, 0x63, 0x68,
    0x65, 0x6d, 0x61, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6b, 0x75, 0x64,
    0x75, 0x2e, 0x50, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d,
    0x61, 0x50, 0x42, 0x2e, 0x48, 0x61, 0x73, 0x68, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x53, 0x63,
    0x68, 0x65, 0x6d, 0x61, 0x50, 0x42, 0x12, 0x3b, 0x0a, 0x0c, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x5f,
    0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x6b,
    0x75, 0x64, 0x75, 0x2e, 0x50, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x63, 0x68,
    0x65, 0x6d, 0x61, 0x50, 0x42, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x53, 0x63, 0x68, 0x65, 0x6d,
    0x61, 0x50, 0x42, 0x1a, 0x40, 0x0a, 0x12, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x49, 0x64, 0x65,
    0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x50, 0x42, 0x12, 0x0c, 0x0a, 0x02, 0x69, 0x64, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x12, 0x0e, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x42, 0x0c, 0x0a, 0x0a, 0x69, 0x64, 0x65, 0x6e, 0x74,
    0x69, 0x66, 0x69, 0x65, 0x72, 0x1a, 0x4c, 0x0a, 0x0d, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x53, 0x63,
    0x68, 0x65, 0x6d, 0x61, 0x50, 0x42, 0x12, 0x3b, 0x0a, 0x07, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e,
    0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6b, 0x75, 0x64, 0x75, 0x2e, 0x50,
    0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x50, 0x42,
    0x2e, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65,
    0x72, 0x50, 0x42, 0x1a, 0xf7, 0x01, 0x0a, 0x12, 0x48, 0x61, 0x73, 0x68, 0x42, 0x75, 0x63, 0x6b,
    0x65, 0x74, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x50, 0x42, 0x12, 0x3b, 0x0a, 0x07, 0x63, 0x6f,
    0x6c, 0x75, 0x6d, 0x6e, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6b, 0x75,
    0x64, 0x75, 0x2e, 0x50, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65,
    0x6d, 0x61, 0x50, 0x42, 0x2e, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x49, 0x64, 0x65, 0x6e, 0x74,
    0x69, 0x66, 0x69, 0x65, 0x72, 0x50, 0x42, 0x12, 0x13, 0x0a, 0x0b, 0x6e, 0x75, 0x6d, 0x5f, 0x62,
    0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18, 0x02, 0x20, 0x02, 0x28, 0x05, 0x12, 0x0c, 0x0a, 0x04,
    0x73, 0x65, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x50, 0x0a, 0x0e, 0x68, 0x61,
    0x73, 0x68, 0x5f, 0x61, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x18, 0x04, 0x20, 0x01,
    0x28, 0x0e, 0x32, 0x38, 0x2e, 0x6b, 0x75, 0x64, 0x75, 0x2e, 0x50, 0x61, 0x72, 0x74, 0x69, 0x74,
    0x69, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x50, 0x42, 0x2e, 0x48, 0x61, 0x73, 0x68,
    0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x50, 0x42, 0x2e, 0x48,
    0x61, 0x73, 0x68, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x22, 0x2f, 0x0a, 0x0d,
    0x48, 0x61, 0x73, 0x68, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x12, 0x0b, 0x0a,
    0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x11, 0x0a, 0x0d, 0x4d, 0x55,
    0x52, 0x4d, 0x55, 0x52, 0x5f, 0x48, 0x41, 0x53, 0x48, 0x5f, 0x32, 0x10, 0x01, 0x22, 0x5f, 0x0a,
    0x0b, 0x50, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x42, 0x12, 0x18, 0x0a, 0x0c,
    0x68, 0x61, 0x73, 0x68, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03,
    0x28, 0x05, 0x42, 0x02, 0x10, 0x01, 0x12, 0x1b, 0x0a, 0x13, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74,
    0x69, 0x6f, 0x6e, 0x5f, 0x6b, 0x65, 0x79, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x0c, 0x12, 0x19, 0x0a, 0x11, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e,
    0x5f, 0x6b, 0x65, 0x79, 0x5f, 0x65, 0x6e, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x22, 0x9f,
    0x02, 0x0a, 0x11, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x50, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61,
    0x74, 0x65, 0x50, 0x42, 0x12, 0x0e, 0x0a, 0x06, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x09, 0x12, 0x2e, 0x0a, 0x05, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x6b, 0x75, 0x64, 0x75, 0x2e, 0x43, 0x6f, 0x6c, 0x75, 0x6d,
    0x6e, 0x50, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x50, 0x42, 0x2e, 0x52, 0x61, 0x6e,
    0x67, 0x65, 0x48, 0x00, 0x12, 0x34, 0x0a, 0x08, 0x65, 0x71, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79,
    0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x6b, 0x75, 0x64, 0x75, 0x2e, 0x43, 0x6f,
    0x6c, 0x75, 0x6d, 0x6e, 0x50, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x50, 0x42, 0x2e,
    0x45, 0x71, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x48, 0x00, 0x12, 0x38, 0x0a, 0x0b, 0x69, 0x73,
    0x5f, 0x6e, 0x6f, 0x74, 0x5f, 0x6e, 0x75, 0x6c, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x21, 0x2e, 0x6b, 0x75, 0x64, 0x75, 0x2e, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x50, 0x72, 0x65,
    0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x50, 0x42, 0x2e, 0x49, 0x73, 0x4e, 0x6f, 0x74, 0x4e, 0x75,
    0x6c, 0x6c, 0x48, 0x00, 0x1a, 0x25, 0x0a, 0x05, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x0d, 0x0a,
    0x05, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x0d, 0x0a, 0x05,
    0x75, 0x70, 0x70, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x1a, 0x19, 0x0a, 0x08, 0x45,
    0x71, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x1a, 0x0b, 0x0a, 0x09, 0x49, 0x73, 0x4e, 0x6f, 0x74, 0x4e,
    0x75, 0x6c, 0x6c, 0x42, 0x0b, 0x0a, 0x09, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65,
    0x2a, 0xbf, 0x01, 0x0a, 0x08, 0x44, 0x61, 0x74, 0x61, 0x54, 0x79, 0x70, 0x65, 0x12, 0x11, 0x0a,
    0x0c, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x5f, 0x44, 0x41, 0x54, 0x41, 0x10, 0xe7, 0x07,
    0x12, 0x09, 0x0a, 0x05, 0x55, 0x49, 0x4e, 0x54, 0x38, 0x10, 0x00, 0x12, 0x08, 0x0a, 0x04, 0x49,
    0x4e, 0x54, 0x38, 0x10, 0x01, 0x12, 0x0a, 0x0a, 0x06, 0x55, 0x49, 0x4e, 0x54, 0x31, 0x36, 0x10,
    0x02, 0x12, 0x09, 0x0a, 0x05, 0x49, 0x4e, 0x54, 0x31, 0x36, 0x10, 0x03, 0x12, 0x0a, 0x0a, 0x06,
    0x55, 0x49, 0x4e, 0x54, 0x33, 0x32, 0x10, 0x04, 0x12, 0x09, 0x0a, 0x05, 0x49, 0x4e, 0x54, 0x33,
    0x32, 0x10, 0x05, 0x12, 0x0a, 0x0a, 0x06, 0x55, 0x49, 0x4e, 0x54, 0x36, 0x34, 0x10, 0x06, 0x12,
    0x09, 0x0a, 0x05, 0x49, 0x4e, 0x54, 0x36, 0x34, 0x10, 0x07, 0x12, 0x0a, 0x0a, 0x06, 0x53, 0x54,
    0x52, 0x49, 0x4e, 0x47, 0x10, 0x08, 0x12, 0x08, 0x0a, 0x04, 0x42, 0x4f, 0x4f, 0x4c, 0x10, 0x09,
    0x12, 0x09, 0x0a, 0x05, 0x46, 0x4c, 0x4f, 0x41, 0x54, 0x10, 0x0a, 0x12, 0x0a, 0x0a, 0x06, 0x44,
    0x4f, 0x55, 0x42, 0x4c, 0x45, 0x10, 0x0b, 0x12, 0x0a, 0x0a, 0x06, 0x42, 0x49, 0x4e, 0x41, 0x52,
    0x59, 0x10, 0x0c, 0x12, 0x0d, 0x0a, 0x09, 0x54, 0x49, 0x4d, 0x45, 0x53, 0x54, 0x41, 0x4d, 0x50,
    0x10, 0x0d, 0x2a, 0xa0, 0x01, 0x0a, 0x0c, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x54,
    0x79, 0x70, 0x65, 0x12, 0x15, 0x0a, 0x10, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x5f, 0x45,
    0x4e, 0x43, 0x4f, 0x44, 0x49, 0x4e, 0x47, 0x10, 0xe7, 0x07, 0x12, 0x11, 0x0a, 0x0d, 0x41, 0x55,
    0x54, 0x4f, 0x5f, 0x45, 0x4e, 0x43, 0x4f, 0x44, 0x49, 0x4e, 0x47, 0x10, 0x00, 0x12, 0x12, 0x0a,
    0x0e, 0x50, 0x4c, 0x41, 0x49, 0x4e, 0x5f, 0x45, 0x4e, 0x43, 0x4f, 0x44, 0x49, 0x4e, 0x47, 0x10,
    0x01, 0x12, 0x13, 0x0a, 0x0f, 0x50, 0x52, 0x45, 0x46, 0x49, 0x58, 0x5f, 0x45, 0x4e, 0x43, 0x4f,
    0x44, 0x49, 0x4e, 0x47, 0x10, 0x02, 0x12, 0x10, 0x0a, 0x0c, 0x47, 0x52, 0x4f, 0x55, 0x50, 0x5f,
    0x56, 0x41, 0x52, 0x49, 0x4e, 0x54, 0x10, 0x03, 0x12, 0x07, 0x0a, 0x03, 0x52, 0x4c, 0x45, 0x10,
    0x04, 0x12, 0x11, 0x0a, 0x0d, 0x44, 0x49, 0x43, 0x54, 0x5f, 0x45, 0x4e, 0x43, 0x4f, 0x44, 0x49,
    0x4e, 0x47, 0x10, 0x05, 0x12, 0x0f, 0x0a, 0x0b, 0x42, 0x49, 0x54, 0x5f, 0x53, 0x48, 0x55, 0x46,
    0x46, 0x4c, 0x45, 0x10, 0x06, 0x2a, 0x77, 0x0a, 0x0f, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73,
    0x73, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x18, 0x0a, 0x13, 0x55, 0x4e, 0x4b, 0x4e,
    0x4f, 0x57, 0x4e, 0x5f, 0x43, 0x4f, 0x4d, 0x50, 0x52, 0x45, 0x53, 0x53, 0x49, 0x4f, 0x4e, 0x10,
    0xe7, 0x07, 0x12, 0x17, 0x0a, 0x13, 0x44, 0x45, 0x46, 0x41, 0x55, 0x4c, 0x54, 0x5f, 0x43, 0x4f,
    0x4d, 0x50, 0x52, 0x45, 0x53, 0x53, 0x49, 0x4f, 0x4e, 0x10, 0x00, 0x12, 0x12, 0x0a, 0x0e, 0x4e,
    0x4f, 0x5f, 0x43, 0x4f, 0x4d, 0x50, 0x52, 0x45, 0x53, 0x53, 0x49, 0x4f, 0x4e, 0x10, 0x01, 0x12,
    0x0a, 0x0a, 0x06, 0x53, 0x4e, 0x41, 0x50, 0x50, 0x59, 0x10, 0x02, 0x12, 0x07, 0x0a, 0x03, 0x4c,
    0x5a, 0x34, 0x10, 0x03, 0x12, 0x08, 0x0a, 0x04, 0x5a, 0x4c, 0x49, 0x42, 0x10, 0x04, 0x2a, 0x68,
    0x0a, 0x17, 0x45, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x43, 0x6f, 0x6e, 0x73, 0x69, 0x73,
    0x74, 0x65, 0x6e, 0x63, 0x79, 0x4d, 0x6f, 0x64, 0x65, 0x12, 0x25, 0x0a, 0x21, 0x55, 0x4e, 0x4b,
    0x4e, 0x4f, 0x57, 0x4e, 0x5f, 0x45, 0x58, 0x54, 0x45, 0x52, 0x4e, 0x41, 0x4c, 0x5f, 0x43, 0x4f,
    0x4e, 0x53, 0x49, 0x53, 0x54, 0x45, 0x4e, 0x43, 0x59, 0x5f, 0x4d, 0x4f, 0x44, 0x45, 0x10, 0x00,
    0x12, 0x15, 0x0a, 0x11, 0x43, 0x4c, 0x49, 0x45, 0x4e, 0x54, 0x5f, 0x50, 0x52, 0x4f, 0x50, 0x41,
    0x47, 0x41, 0x54, 0x45, 0x44, 0x10, 0x01, 0x12, 0x0f, 0x0a, 0x0b, 0x43, 0x4f, 0x4d, 0x4d, 0x49,
    0x54, 0x5f, 0x57, 0x41, 0x49, 0x54, 0x10, 0x02, 0x2a, 0x48, 0x0a, 0x08, 0x52, 0x65, 0x61, 0x64,
    0x4d, 0x6f, 0x64, 0x65, 0x12, 0x15, 0x0a, 0x11, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x5f,
    0x52, 0x45, 0x41, 0x44, 0x5f, 0x4d, 0x4f, 0x44, 0x45, 0x10, 0x00, 0x12, 0x0f, 0x0a, 0x0b, 0x52,
    0x45, 0x41, 0x44, 0x5f, 0x4c, 0x41, 0x54, 0x45, 0x53, 0x54, 0x10, 0x01, 0x12, 0x14, 0x0a, 0x10,
    0x52, 0x45, 0x41, 0x44, 0x5f, 0x41, 0x54, 0x5f, 0x53, 0x4e, 0x41, 0x50, 0x53, 0x48, 0x4f, 0x54,
    0x10, 0x02, 0x2a, 0x3f, 0x0a, 0x09, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x4d, 0x6f, 0x64, 0x65, 0x12,
    0x16, 0x0a, 0x12, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x5f, 0x4f, 0x52, 0x44, 0x45, 0x52,
    0x5f, 0x4d, 0x4f, 0x44, 0x45, 0x10, 0x00, 0x12, 0x0d, 0x0a, 0x09, 0x55, 0x4e, 0x4f, 0x52, 0x44,
    0x45, 0x52, 0x45, 0x44, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x4f, 0x52, 0x44, 0x45, 0x52, 0x45,
    0x44, 0x10, 0x02, 0x42, 0x0c, 0x0a, 0x0a, 0x6f, 0x72, 0x67, 0x2e, 0x6b, 0x75, 0x64, 0x75, 0x64,
    0x62, 0x4a, 0x89, 0x63, 0x0a, 0x07, 0x12, 0x05, 0x19, 0x00, 0xb4, 0x02, 0x01, 0x0a, 0x98, 0x09,
    0x0a, 0x01, 0x02, 0x12, 0x03, 0x19, 0x08, 0x0c, 0x1a, 0x8d, 0x09, 0x20, 0x4c, 0x69, 0x63, 0x65,
    0x6e, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x41, 0x70, 0x61, 0x63,
    0x68, 0x65, 0x20, 0x53, 0x6f, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65, 0x20, 0x46, 0x6f, 0x75, 0x6e,
    0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28, 0x41, 0x53, 0x46, 0x29, 0x20, 0x75, 0x6e, 0x64,
    0x65, 0x72, 0x20, 0x6f, 0x6e, 0x65, 0x0a, 0x20, 0x6f, 0x72, 0x20, 0x6d, 0x6f, 0x72, 0x65, 0x20,
    0x63, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x6c, 0x69, 0x63, 0x65,
    0x6e, 0x73, 0x65, 0x20, 0x61, 0x67, 0x72, 0x65, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x20,
    0x20, 0x53, 0x65, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4e, 0x4f, 0x54, 0x49, 0x43, 0x45, 0x20,
    0x66, 0x69, 0x6c, 0x65, 0x0a, 0x20, 0x64, 0x69, 0x73, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65,
    0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x77, 0x6f, 0x72, 0x6b,
    0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20,
    0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x72, 0x65, 0x67,
    0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x63, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74,
    0x20, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0x2e, 0x20, 0x20, 0x54, 0x68, 0x65,
    0x20, 0x41, 0x53, 0x46, 0x20, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x73, 0x20, 0x74, 0x68,
    0x69, 0x73, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x0a, 0x20, 0x74, 0x6f, 0x20, 0x79, 0x6f, 0x75, 0x20,
    0x75, 0x6e, 0x64, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x41, 0x70, 0x61, 0x63, 0x68, 0x65,
    0x20, 0x4c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x2c, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f,
    0x6e, 0x20, 0x32, 0x2e, 0x30, 0x20, 0x28, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x22, 0x4c, 0x69, 0x63,
    0x65, 0x6e, 0x73, 0x65, 0x22, 0x29, 0x3b, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6d, 0x61, 0x79, 0x20,
    0x6e, 0x6f, 0x74, 0x20, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x6c,
    0x65, 0x20, 0x65, 0x78, 0x63, 0x65, 0x70, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x63, 0x6f, 0x6d, 0x70,
    0x6c, 0x69, 0x61, 0x6e, 0x63, 0x65, 0x0a, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x4c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x2e, 0x20, 0x20, 0x59, 0x6f, 0x75, 0x20, 0x6d,
    0x61, 0x79, 0x20, 0x6f, 0x62, 0x74, 0x61, 0x69, 0x6e, 0x20, 0x61, 0x20, 0x63, 0x6f, 0x70, 0x79,
    0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x20,
    0x61, 0x74, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77,
    0x77, 0x2e, 0x61, 0x70, 0x61, 0x63, 0x68, 0x65, 0x2e, 0x6f, 0x72, 0x67, 0x2f, 0x6c, 0x69, 0x63,
    0x65, 0x6e, 0x73, 0x65, 0x73, 0x2f, 0x4c, 0x49, 0x43, 0x45, 0x4e, 0x53, 0x45, 0x2d, 0x32, 0x2e,
    0x30, 0x0a, 0x0a, 0x20, 0x55, 0x6e, 0x6c, 0x65, 0x73, 0x73, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69,
    0x72, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x62, 0x6c,
    0x65, 0x20, 0x6c, 0x61, 0x77, 0x20, 0x6f, 0x72, 0x20, 0x61, 0x67, 0x72, 0x65, 0x65, 0x64, 0x20,
    0x74, 0x6f, 0x20, 0x69, 0x6e, 0x20, 0x77, 0x72, 0x69, 0x74, 0x69, 0x6e, 0x67, 0x2c, 0x0a, 0x20,
    0x73, 0x6f, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65, 0x20, 0x64, 0x69, 0x73, 0x74, 0x72, 0x69, 0x62,
    0x75, 0x74, 0x65, 0x64, 0x20, 0x75, 0x6e, 0x64, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4c,
    0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x20, 0x69, 0x73, 0x20, 0x64, 0x69, 0x73, 0x74, 0x72, 0x69,
    0x62, 0x75, 0x74, 0x65, 0x64, 0x20, 0x6f, 0x6e, 0x20, 0x61, 0x6e, 0x0a, 0x20, 0x22, 0x41, 0x53,
    0x20, 0x49, 0x53, 0x22, 0x20, 0x42, 0x41, 0x53, 0x49, 0x53, 0x2c, 0x20, 0x57, 0x49, 0x54, 0x48,
    0x4f, 0x55, 0x54, 0x20, 0x57, 0x41, 0x52, 0x52, 0x41, 0x4e, 0x54, 0x49, 0x45, 0x53, 0x20, 0x4f,
    0x52, 0x20, 0x43, 0x4f, 0x4e, 0x44, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x53, 0x20, 0x4f, 0x46, 0x20,
    0x41, 0x4e, 0x59, 0x0a, 0x20, 0x4b, 0x49, 0x4e, 0x44, 0x2c, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65,
    0x72, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x20, 0x6f, 0x72, 0x20, 0x69, 0x6d, 0x70,
    0x6c, 0x69, 0x65, 0x64, 0x2e, 0x20, 0x20, 0x53, 0x65, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4c,
    0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20,
    0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x20, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
    0x65, 0x20, 0x67, 0x6f, 0x76, 0x65, 0x72, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x70, 0x65, 0x72, 0x6d,
    0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6c, 0x69, 0x6d, 0x69,
    0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x0a, 0x20, 0x75, 0x6e, 0x64, 0x65, 0x72, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x4c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x2e, 0x0a, 0x0a, 0x20, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x73, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x61, 0x72,
    0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68,
    0x6f, 0x75, 0x74, 0x20, 0x4b, 0x75, 0x64, 0x75, 0x2e, 0x0a, 0x0a, 0x20, 0x54, 0x68, 0x69, 0x73,
    0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69,
    0x6e, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x73, 0x20, 0x77, 0x68, 0x69, 0x63,
    0x68, 0x20, 0x61, 0x72, 0x65, 0x20, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x64, 0x20,
    0x6f, 0x6e, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x0a, 0x20, 0x61, 0x73, 0x20, 0x77, 0x65, 0x6c, 0x6c,
    0x20, 0x61, 0x73, 0x20, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x77, 0x69, 0x72, 0x65, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x61, 0x20, 0x70, 0x61, 0x72, 0x74, 0x69,
    0x63, 0x75, 0x6c, 0x61, 0x72, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x20, 0x69,
    0x73, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x0a, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20,
    0x70, 0x61, 0x72, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x2d, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x77, 0x69, 0x72, 0x65, 0x20, 0x70,
    0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x73, 0x68, 0x6f, 0x75,
    0x6c, 0x64, 0x20, 0x67, 0x6f, 0x0a, 0x20, 0x69, 0x6e, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
    0x2f, 0x77, 0x69, 0x72, 0x65, 0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x70,
    0x72, 0x6f, 0x74, 0x6f, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x65, 0x61, 0x64, 0x2e, 0x20, 0x49, 0x66,
    0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x75, 0x73, 0x65, 0x64,
    0x20, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6e, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72,
    0x76, 0x65, 0x72, 0x28, 0x73, 0x29, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c,
    0x64, 0x20, 0x67, 0x6f, 0x20, 0x69, 0x6e, 0x20, 0x63, 0x66, 0x69, 0x6c, 0x65, 0x2f, 0x63, 0x66,
    0x69, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2c, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65,
    0x72, 0x2f, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
    0x2c, 0x0a, 0x20, 0x65, 0x74, 0x63, 0x2c, 0x20, 0x61, 0x73, 0x20, 0x61, 0x70, 0x70, 0x72, 0x6f,
    0x70, 0x72, 0x69, 0x61, 0x74, 0x65, 0x2e, 0x0a, 0x0a, 0x08, 0x0a, 0x01, 0x08, 0x12, 0x03, 0x1b,
    0x00, 0x23, 0x0a, 0x0b, 0x0a, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x03, 0x1b, 0x00, 0x23, 0x0a,
    0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x03, 0x1b, 0x07, 0x13, 0x0a, 0x0d, 0x0a,
    0x06, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x03, 0x1b, 0x07, 0x13, 0x0a, 0x0e, 0x0a, 0x07,
    0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x1b, 0x07, 0x13, 0x0a, 0x0c, 0x0a, 0x05,
    0x08, 0xe7, 0x07, 0x00, 0x07, 0x12, 0x03, 0x1b, 0x16, 0x22, 0x0a, 0xc6, 0x01, 0x0a, 0x02, 0x05,
    0x00, 0x12, 0x04, 0x20, 0x00, 0x30, 0x01, 0x1a, 0xb9, 0x01, 0x20, 0x49, 0x66, 0x20, 0x79, 0x6f,
    0x75, 0x20, 0x61, 0x64, 0x64, 0x20, 0x61, 0x20, 0x6e, 0x65, 0x77, 0x20, 0x74, 0x79, 0x70, 0x65,
    0x20, 0x6b, 0x65, 0x65, 0x70, 0x20, 0x69, 0x6e, 0x20, 0x6d, 0x69, 0x6e, 0x64, 0x20, 0x74, 0x6f,
    0x20, 0x61, 0x64, 0x64, 0x20, 0x69, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65,
    0x6e, 0x64, 0x0a, 0x20, 0x6f, 0x72, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x41, 0x64,
    0x64, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x28, 0x29, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74,
    0x69, 0x6f, 0x6e, 0x73, 0x20, 0x6c, 0x69, 0x6b, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6f, 0x6e,
    0x65, 0x20, 0x69, 0x6e, 0x20, 0x6b, 0x65, 0x79, 0x5f, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x72,
    0x2e, 0x63, 0x63, 0x0a, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x61,
    0x20, 0x76, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6d, 0x61, 0x70,
    0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x20, 0x74,
    0x61, 0x67, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6e, 0x64, 0x65,
    0x78, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x05, 0x00, 0x01, 0x12, 0x03, 0x20, 0x05, 0x0d, 0x0a,
    0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x00, 0x12, 0x03, 0x21, 0x02, 0x15, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x21, 0x02, 0x0e, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00,
    0x02, 0x00, 0x02, 0x12, 0x03, 0x21, 0x11, 0x14, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x01,
    0x12, 0x03, 0x22, 0x02, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x01, 0x01, 0x12, 0x03,
    0x22, 0x02, 0x07, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x01, 0x02, 0x12, 0x03, 0x22, 0x0a,
    0x0b, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x02, 0x12, 0x03, 0x23, 0x02, 0x0b, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x00, 0x02, 0x02, 0x01, 0x12, 0x03, 0x23, 0x02, 0x06, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x00, 0x02, 0x02, 0x02, 0x12, 0x03, 0x23, 0x09, 0x0a, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00,
    0x02, 0x03, 0x12, 0x03, 0x24, 0x02, 0x0d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x03, 0x01,
    0x12, 0x03, 0x24, 0x02, 0x08, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x03, 0x02, 0x12, 0x03,
    0x24, 0x0b, 0x0c, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x04, 0x12, 0x03, 0x25, 0x02, 0x0c,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x04, 0x01, 0x12, 0x03, 0x25, 0x02, 0x07, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x00, 0x02, 0x04, 0x02, 0x12, 0x03, 0x25, 0x0a, 0x0b, 0x0a, 0x0b, 0x0a, 0x04,
    0x05, 0x00, 0x02, 0x05, 0x12, 0x03, 0x26, 0x02, 0x0d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02,
    0x05, 0x01, 0x12, 0x03, 0x26, 0x02, 0x08, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x05, 0x02,
    0x12, 0x03, 0x26, 0x0b, 0x0c, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x06, 0x12, 0x03, 0x27,
    0x02, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x06, 0x01, 0x12, 0x03, 0x27, 0x02, 0x07,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x06, 0x02, 0x12, 0x03, 0x27, 0x0a, 0x0b, 0x0a, 0x0b,
    0x0a, 0x04, 0x05, 0x00, 0x02, 0x07, 0x12, 0x03, 0x28, 0x02, 0x0d, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x00, 0x02, 0x07, 0x01, 0x12, 0x03, 0x28, 0x02, 0x08, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02,
    0x07, 0x02, 0x12, 0x03, 0x28, 0x0b, 0x0c, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x08, 0x12,
    0x03, 0x29, 0x02, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x08, 0x01, 0x12, 0x03, 0x29,
    0x02, 0x07, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x08, 0x02, 0x12, 0x03, 0x29, 0x0a, 0x0b,
    0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x09, 0x12, 0x03, 0x2a, 0x02, 0x0d, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x00, 0x02, 0x09, 0x01, 0x12, 0x03, 0x2a, 0x02, 0x08, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x00, 0x02, 0x09, 0x02, 0x12, 0x03, 0x2a, 0x0b, 0x0c, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02,
    0x0a, 0x12, 0x03, 0x2b, 0x02, 0x0b, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0a, 0x01, 0x12,
    0x03, 0x2b, 0x02, 0x06, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0a, 0x02, 0x12, 0x03, 0x2b,
    0x09, 0x0a, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x0b, 0x12, 0x03, 0x2c, 0x02, 0x0d, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0b, 0x01, 0x12, 0x03, 0x2c, 0x02, 0x07, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x00, 0x02, 0x0b, 0x02, 0x12, 0x03, 0x2c, 0x0a, 0x0c, 0x0a, 0x0b, 0x0a, 0x04, 0x05,
    0x00, 0x02, 0x0c, 0x12, 0x03, 0x2d, 0x02, 0x0e, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0c,
    0x01, 0x12, 0x03, 0x2d, 0x02, 0x08, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0c, 0x02, 0x12,
    0x03, 0x2d, 0x0b, 0x0d, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x0d, 0x12, 0x03, 0x2e, 0x02,
    0x0e, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0d, 0x01, 0x12, 0x03, 0x2e, 0x02, 0x08, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0d, 0x02, 0x12, 0x03, 0x2e, 0x0b, 0x0d, 0x0a, 0x0b, 0x0a,
    0x04, 0x05, 0x00, 0x02, 0x0e, 0x12, 0x03, 0x2f, 0x02, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00,
    0x02, 0x0e, 0x01, 0x12, 0x03, 0x2f, 0x02, 0x0b, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x0e,
    0x02, 0x12, 0x03, 0x2f, 0x0e, 0x10, 0x0a, 0x0a, 0x0a, 0x02, 0x05, 0x01, 0x12, 0x04, 0x32, 0x00,
    0x3b, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x05, 0x01, 0x01, 0x12, 0x03, 0x32, 0x05, 0x11, 0x0a, 0x0b,
    0x0a, 0x04, 0x05, 0x01, 0x02, 0x00, 0x12, 0x03, 0x33, 0x02, 0x19, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x01, 0x02, 0x00, 0x01, 0x12, 0x03, 0x33, 0x02, 0x12, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02,
    0x00, 0x02, 0x12, 0x03, 0x33, 0x15, 0x18, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x01, 0x12,
    0x03, 0x34, 0x02, 0x14, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x01, 0x01, 0x12, 0x03, 0x34,
    0x02, 0x0f, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x01, 0x02, 0x12, 0x03, 0x34, 0x12, 0x13,
    0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x02, 0x12, 0x03, 0x35, 0x02, 0x15, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x01, 0x02, 0x02, 0x01, 0x12, 0x03, 0x35, 0x02, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x01, 0x02, 0x02, 0x02, 0x12, 0x03, 0x35, 0x13, 0x14, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x01, 0x02,
    0x03, 0x12, 0x03, 0x36, 0x02, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x03, 0x01, 0x12,
    0x03, 0x36, 0x02, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x03, 0x02, 0x12, 0x03, 0x36,
    0x14, 0x15, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x04, 0x12, 0x03, 0x37, 0x02, 0x13, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x04, 0x01, 0x12, 0x03, 0x37, 0x02, 0x0e, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x01, 0x02, 0x04, 0x02, 0x12, 0x03, 0x37, 0x11, 0x12, 0x0a, 0x0b, 0x0a, 0x04, 0x05,
    0x01, 0x02, 0x05, 0x12, 0x03, 0x38, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x05,
    0x01, 0x12, 0x03, 0x38, 0x02, 0x05, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x05, 0x02, 0x12,
    0x03, 0x38, 0x08, 0x09, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x06, 0x12, 0x03, 0x39, 0x02,
    0x14, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x06, 0x01, 0x12, 0x03, 0x39, 0x02, 0x0f, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x06, 0x02, 0x12, 0x03, 0x39, 0x12, 0x13, 0x0a, 0x0b, 0x0a,
    0x04, 0x05, 0x01, 0x02, 0x07, 0x12, 0x03, 0x3a, 0x02, 0x12, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01,
    0x02, 0x07, 0x01, 0x12, 0x03, 0x3a, 0x02, 0x0d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x07,
    0x02, 0x12, 0x03, 0x3a, 0x10, 0x11, 0x0a, 0x0a, 0x0a, 0x02, 0x05, 0x02, 0x12, 0x04, 0x3d, 0x00,
    0x44, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x05, 0x02, 0x01, 0x12, 0x03, 0x3d, 0x05, 0x14, 0x0a, 0x0b,
    0x0a, 0x04, 0x05, 0x02, 0x02, 0x00, 0x12, 0x03, 0x3e, 0x02, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x02, 0x02, 0x00, 0x01, 0x12, 0x03, 0x3e, 0x02, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02,
    0x00, 0x02, 0x12, 0x03, 0x3e, 0x18, 0x1b, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x01, 0x12,
    0x03, 0x3f, 0x02, 0x1a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x01, 0x01, 0x12, 0x03, 0x3f,
    0x02, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x01, 0x02, 0x12, 0x03, 0x3f, 0x18, 0x19,
    0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x02, 0x12, 0x03, 0x40, 0x02, 0x15, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x02, 0x02, 0x02, 0x01, 0x12, 0x03, 0x40, 0x02, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x02, 0x02, 0x02, 0x02, 0x12, 0x03, 0x40, 0x13, 0x14, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02,
    0x03, 0x12, 0x03, 0x41, 0x02, 0x0d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x03, 0x01, 0x12,
    0x03, 0x41, 0x02, 0x08, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x03, 0x02, 0x12, 0x03, 0x41,
    0x0b, 0x0c, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x04, 0x12, 0x03, 0x42, 0x02, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x04, 0x01, 0x12, 0x03, 0x42, 0x02, 0x05, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x02, 0x02, 0x04, 0x02, 0x12, 0x03, 0x42, 0x08, 0x09, 0x0a, 0x0b, 0x0a, 0x04, 0x05,
    0x02, 0x02, 0x05, 0x12, 0x03, 0x43, 0x02, 0x0b, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x05,
    0x01, 0x12, 0x03, 0x43, 0x02, 0x06, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x05, 0x02, 0x12,
    0x03, 0x43, 0x09, 0x0a, 0x0a, 0xb3, 0x01, 0x0a, 0x02, 0x04, 0x00, 0x12, 0x04, 0x4a, 0x00, 0x58,
    0x01, 0x1a, 0xa6, 0x01, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x3a, 0x20, 0x44, 0x69, 0x66, 0x66, 0x65,
    0x72, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x74, 0x65, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x20, 0x61, 0x74, 0x74, 0x72,
    0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x0a, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x72, 0x65,
    0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x72, 0x65, 0x6c, 0x65, 0x76, 0x61, 0x6e, 0x74, 0x20, 0x74,
    0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x28, 0x65, 0x2e,
    0x67, 0x2e, 0x2c, 0x0a, 0x20, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e,
    0x64, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x29, 0x20, 0x61,
    0x6e, 0x64, 0x20, 0x74, 0x68, 0x6f, 0x73, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x6c,
    0x73, 0x6f, 0x0a, 0x20, 0x6d, 0x61, 0x74, 0x74, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x00,
    0x01, 0x12, 0x03, 0x4a, 0x08, 0x16, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x00, 0x12, 0x03,
    0x4b, 0x02, 0x19, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x04, 0x12, 0x03, 0x4b, 0x02,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x05, 0x12, 0x03, 0x4b, 0x0b, 0x11, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x4b, 0x12, 0x14, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x00, 0x02, 0x00, 0x03, 0x12, 0x03, 0x4b, 0x17, 0x18, 0x0a, 0x0b, 0x0a, 0x04, 0x04,
    0x00, 0x02, 0x01, 0x12, 0x03, 0x4c, 0x02, 0x1b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01,
    0x04, 0x12, 0x03, 0x4c, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x05, 0x12,
    0x03, 0x4c, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x03, 0x4c,
    0x12, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x03, 0x12, 0x03, 0x4c, 0x19, 0x1a,
    0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x02, 0x12, 0x03, 0x4d, 0x02, 0x1d, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x00, 0x02, 0x02, 0x04, 0x12, 0x03, 0x4d, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x00, 0x02, 0x02, 0x06, 0x12, 0x03, 0x4d, 0x0b, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x02, 0x01, 0x12, 0x03, 0x4d, 0x14, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x02, 0x03,
    0x12, 0x03, 0x4d, 0x1b, 0x1c, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x03, 0x12, 0x03, 0x4e,
    0x02, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x03, 0x04, 0x12, 0x03, 0x4e, 0x02, 0x0a,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x03, 0x05, 0x12, 0x03, 0x4e, 0x0b, 0x0f, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x00, 0x02, 0x03, 0x01, 0x12, 0x03, 0x4e, 0x10, 0x16, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x00, 0x02, 0x03, 0x03, 0x12, 0x03, 0x4e, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00,
    0x02, 0x03, 0x08, 0x12, 0x03, 0x4e, 0x1b, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x03,
    0x07, 0x12, 0x03, 0x4e, 0x26, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x04, 0x12, 0x03,
    0x4f, 0x02, 0x32, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x04, 0x04, 0x12, 0x03, 0x4f, 0x02,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x04, 0x05, 0x12, 0x03, 0x4f, 0x0b, 0x0f, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x04, 0x01, 0x12, 0x03, 0x4f, 0x10, 0x1b, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x00, 0x02, 0x04, 0x03, 0x12, 0x03, 0x4f, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x00, 0x02, 0x04, 0x08, 0x12, 0x03, 0x4f, 0x20, 0x31, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x04, 0x07, 0x12, 0x03, 0x4f, 0x2b, 0x30, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x05, 0x12,
    0x03, 0x50, 0x02, 0x28, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x05, 0x04, 0x12, 0x03, 0x50,
    0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x05, 0x05, 0x12, 0x03, 0x50, 0x0b, 0x10,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x05, 0x01, 0x12, 0x03, 0x50, 0x11, 0x23, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x00, 0x02, 0x05, 0x03, 0x12, 0x03, 0x50, 0x26, 0x27, 0x0a, 0x0b, 0x0a, 0x04,
    0x04, 0x00, 0x02, 0x06, 0x12, 0x03, 0x51, 0x02, 0x29, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x06, 0x04, 0x12, 0x03, 0x51, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x06, 0x05,
    0x12, 0x03, 0x51, 0x0b, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x06, 0x01, 0x12, 0x03,
    0x51, 0x11, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x06, 0x03, 0x12, 0x03, 0x51, 0x27,
    0x28, 0x0a, 0x84, 0x01, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x07, 0x12, 0x03, 0x55, 0x02, 0x3d, 0x1a,
    0x77, 0x20, 0x54, 0x68, 0x65, 0x20, 0x66, 0x6f, 0x6c, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x20,
    0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x20, 0x72, 0x65, 0x66, 0x65, 0x72,
    0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6f, 0x6e, 0x2d, 0x64, 0x69, 0x73, 0x6b, 0x20,
    0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63,
    0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x2e, 0x0a, 0x20, 0x54, 0x68, 0x65, 0x79, 0x20, 0x77, 0x6f, 0x6e,
    0x27, 0x74, 0x20, 0x61, 0x6c, 0x77, 0x61, 0x79, 0x73, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x74,
    0x2c, 0x20, 0x64, 0x65, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x6e, 0x20, 0x63,
    0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x07,
    0x04, 0x12, 0x03, 0x55, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x07, 0x06, 0x12,
    0x03, 0x55, 0x0b, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x07, 0x01, 0x12, 0x03, 0x55,
    0x18, 0x20, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x07, 0x03, 0x12, 0x03, 0x55, 0x23, 0x24,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x07, 0x08, 0x12, 0x03, 0x55, 0x25, 0x3c, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x00, 0x02, 0x07, 0x07, 0x12, 0x03, 0x55, 0x2e, 0x3b, 0x0a, 0x0b, 0x0a, 0x04,
    0x04, 0x00, 0x02, 0x08, 0x12, 0x03, 0x56, 0x02, 0x49, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x08, 0x04, 0x12, 0x03, 0x56, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x08, 0x06,
    0x12, 0x03, 0x56, 0x0b, 0x1a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x08, 0x01, 0x12, 0x03,
    0x56, 0x1b, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x08, 0x03, 0x12, 0x03, 0x56, 0x29,
    0x2a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x08, 0x08, 0x12, 0x03, 0x56, 0x2b, 0x48, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x08, 0x07, 0x12, 0x03, 0x56, 0x34, 0x47, 0x0a, 0x0b, 0x0a,
    0x04, 0x04, 0x00, 0x02, 0x09, 0x12, 0x03, 0x57, 0x02, 0x33, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00,
    0x02, 0x09, 0x04, 0x12, 0x03, 0x57, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x09,
    0x05, 0x12, 0x03, 0x57, 0x0b, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x09, 0x01, 0x12,
    0x03, 0x57, 0x11, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x09, 0x03, 0x12, 0x03, 0x57,
    0x24, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x09, 0x08, 0x12, 0x03, 0x57, 0x27, 0x32,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x09, 0x07, 0x12, 0x03, 0x57, 0x30, 0x31, 0x0a, 0x0a,
    0x0a, 0x02, 0x04, 0x01, 0x12, 0x04, 0x5a, 0x00, 0x5c, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x01,
    0x01, 0x12, 0x03, 0x5a, 0x08, 0x10, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x00, 0x12, 0x03,
    0x5b, 0x02, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x04, 0x12, 0x03, 0x5b, 0x02,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x06, 0x12, 0x03, 0x5b, 0x0b, 0x19, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x01, 0x12, 0x03, 0x5b, 0x1a, 0x21, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x01, 0x02, 0x00, 0x03, 0x12, 0x03, 0x5b, 0x24, 0x25, 0x0a, 0x0a, 0x0a, 0x02, 0x04,
    0x02, 0x12, 0x04, 0x5e, 0x00, 0x61, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x02, 0x01, 0x12, 0x03,
    0x5e, 0x08, 0x12, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x00, 0x12, 0x03, 0x5f, 0x02, 0x1b,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x04, 0x12, 0x03, 0x5f, 0x02, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x05, 0x12, 0x03, 0x5f, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x00, 0x01, 0x12, 0x03, 0x5f, 0x12, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x00, 0x03, 0x12, 0x03, 0x5f, 0x19, 0x1a, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x01,
    0x12, 0x03, 0x60, 0x02, 0x1b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01, 0x04, 0x12, 0x03,
    0x60, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01, 0x05, 0x12, 0x03, 0x60, 0x0b,
    0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01, 0x01, 0x12, 0x03, 0x60, 0x12, 0x16, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01, 0x03, 0x12, 0x03, 0x60, 0x19, 0x1a, 0x0a, 0x8e, 0x04,
    0x0a, 0x02, 0x05, 0x03, 0x12, 0x05, 0x6d, 0x00, 0x99, 0x01, 0x01, 0x1a, 0x80, 0x04, 0x20, 0x54,
    0x68, 0x65, 0x20, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x20, 0x63, 0x6f, 0x6e, 0x73,
    0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x20, 0x66, 0x6f, 0x72,
    0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73,
    0x2e, 0x0a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x73, 0x20,
    0x68, 0x6f, 0x77, 0x20, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73,
    0x20, 0x61, 0x6e, 0x64, 0x2f, 0x6f, 0x72, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65,
    0x73, 0x20, 0x6f, 0x66, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20,
    0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x6f, 0x75, 0x63, 0x68, 0x0a, 0x20, 0x73, 0x65, 0x76, 0x65,
    0x72, 0x61, 0x6c, 0x20, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72,
    0x73, 0x2c, 0x20, 0x69, 0x6e, 0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x74, 0x20,
    0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x73, 0x2c, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65,
    0x20, 0x6f, 0x62, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x65, 0x78, 0x74,
    0x65, 0x72, 0x6e, 0x61, 0x6c, 0x0a, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x0a,
    0x0a, 0x20, 0x4e, 0x6f, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x45, 0x78, 0x74, 0x65,
    0x72, 0x6e, 0x61, 0x6c, 0x43, 0x6f, 0x6e, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x4d,
    0x6f, 0x64, 0x65, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x73, 0x20, 0x6e, 0x6f, 0x20, 0x67, 0x75, 0x61,
    0x72, 0x61, 0x6e, 0x74, 0x65, 0x65, 0x20, 0x6f, 0x6e, 0x20, 0x61, 0x74, 0x6f, 0x6d, 0x69, 0x63,
    0x69, 0x74, 0x79, 0x2c, 0x20, 0x69, 0x2e, 0x65, 0x2e, 0x0a, 0x20, 0x6e, 0x6f, 0x20, 0x73, 0x65,
    0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x73, 0x20, 0x69, 0x73, 0x20, 0x6d, 0x61, 0x64, 0x65, 0x20, 0x61, 0x74, 0x6f,
    0x6d, 0x69, 0x63, 0x20, 0x28, 0x6f, 0x72, 0x20, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74,
    0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x29, 0x20, 0x6a, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x63, 0x61,
    0x75, 0x73, 0x65, 0x0a, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c,
    0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x20, 0x6d, 0x6f, 0x64,
    0x65, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x2e, 0x0a, 0x20, 0x4e, 0x6f, 0x74, 0x65, 0x20,
    0x61, 0x6c, 0x73, 0x6f, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x45, 0x78, 0x74, 0x65, 0x72, 0x6e,
    0x61, 0x6c, 0x43, 0x6f, 0x6e, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x4d, 0x6f, 0x64,
    0x65, 0x20, 0x68, 0x61, 0x73, 0x20, 0x6e, 0x6f, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x69, 0x63, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x63, 0x6f, 0x6e,
    0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e,
    0x20, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x74, 0x2e, 0x0a, 0x0a, 0x0a,
    0x0a, 0x03, 0x05, 0x03, 0x01, 0x12, 0x03, 0x6d, 0x05, 0x1c, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x03,
    0x02, 0x00, 0x12, 0x03, 0x6e, 0x02, 0x28, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x00, 0x01,
    0x12, 0x03, 0x6e, 0x02, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x00, 0x02, 0x12, 0x03,
    0x6e, 0x26, 0x27, 0x0a, 0xff, 0x04, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x01, 0x12, 0x04, 0x83, 0x01,
    0x02, 0x18, 0x1a, 0xf0, 0x04, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    0x73, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20,
    0x77, 0x69, 0x6c, 0x6c, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x20, 0x61, 0x20, 0x74,
    0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x0a, 0x20, 0x41, 0x6e, 0x79, 0x20, 0x66,
    0x75, 0x72, 0x74, 0x68, 0x65, 0x72, 0x20, 0x63, 0x61, 0x6c, 0x6c, 0x73, 0x20, 0x66, 0x72, 0x6f,
    0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x20, 0x74, 0x6f, 0x20, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65,
    0x72, 0x73, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x0a, 0x20,
    0x74, 0x68, 0x6f, 0x73, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x20, 0x77, 0x69,
    0x74, 0x68, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
    0x70, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6c, 0x6c,
    0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20, 0x73, 0x75, 0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20,
    0x74, 0x68, 0x65, 0x0a, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x20, 0x69,
    0x73, 0x20, 0x70, 0x72, 0x6f, 0x70, 0x61, 0x67, 0x61, 0x74, 0x65, 0x64, 0x20, 0x74, 0x68, 0x72,
    0x6f, 0x75, 0x67, 0x68, 0x20, 0x62, 0x61, 0x63, 0x6b, 0x2d, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65,
    0x6c, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x0a, 0x20, 0x4b, 0x75, 0x64,
    0x75, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x27, 0x73, 0x2e, 0x0a, 0x0a, 0x20, 0x57, 0x41, 0x52,
    0x4e, 0x49, 0x4e, 0x47, 0x3a, 0x20, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x20, 0x74, 0x6f,
    0x20, 0x70, 0x72, 0x6f, 0x70, 0x61, 0x67, 0x61, 0x74, 0x65, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x73,
    0x74, 0x61, 0x6d, 0x70, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x20, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x0a, 0x20, 0x62, 0x61, 0x63, 0x6b, 0x2d, 0x63,
    0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x65, 0x67,
    0x61, 0x74, 0x65, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c,
    0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x20, 0x67, 0x75, 0x61,
    0x72, 0x61, 0x6e, 0x74, 0x65, 0x65, 0x20, 0x75, 0x6e, 0x64, 0x65, 0x72, 0x20, 0x74, 0x68, 0x69,
    0x73, 0x0a, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x2e, 0x0a, 0x0a, 0x20, 0x45, 0x78, 0x61, 0x6d, 0x70,
    0x6c, 0x65, 0x3a, 0x0a, 0x20, 0x31, 0x20, 0x2d, 0x20, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20,
    0x41, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x73, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x58, 0x20, 0x69, 0x6e, 0x20, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x74,
    0x20, 0x41, 0x0a, 0x20, 0x32, 0x20, 0x2d, 0x20, 0x41, 0x66, 0x74, 0x65, 0x72, 0x77, 0x61, 0x72,
    0x64, 0x73, 0x2c, 0x20, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x41, 0x20, 0x65, 0x78, 0x65,
    0x63, 0x75, 0x74, 0x65, 0x73, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20,
    0x59, 0x20, 0x69, 0x6e, 0x20, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x74, 0x20, 0x42, 0x0a, 0x0a, 0x0a,
    0x20, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x42, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x6f, 0x62,
    0x73, 0x65, 0x72, 0x76, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6f, 0x6c, 0x6c, 0x6f, 0x77,
    0x69, 0x6e, 0x67, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x73, 0x65,
    0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x73, 0x3a, 0x0a, 0x20, 0x7b, 0x7d, 0x2c, 0x20, 0x7b, 0x58,
    0x7d, 0x2c, 0x20, 0x7b, 0x58, 0x20, 0x59, 0x7d, 0x0a, 0x0a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20,
    0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x6d,
    0x6f, 0x64, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x01, 0x01, 0x12, 0x04,
    0x83, 0x01, 0x02, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x01, 0x02, 0x12, 0x04, 0x83,
    0x01, 0x16, 0x17, 0x0a, 0xae, 0x06, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x02, 0x12, 0x04, 0x98, 0x01,
    0x02, 0x12, 0x1a, 0x9f, 0x06, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72,
    0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x67, 0x75, 0x61, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x65, 0x20,
    0x74, 0x68, 0x61, 0x74, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61,
    0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x73, 0x20, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61,
    0x6c, 0x6c, 0x79, 0x0a, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x74, 0x20,
    0x62, 0x79, 0x20, 0x6d, 0x61, 0x6b, 0x69, 0x6e, 0x67, 0x20, 0x73, 0x75, 0x72, 0x65, 0x20, 0x74,
    0x68, 0x61, 0x74, 0x20, 0x6e, 0x6f, 0x6e, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x69, 0x74, 0x73, 0x20,
    0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x76, 0x69, 0x73, 0x69,
    0x62, 0x6c, 0x65, 0x0a, 0x20, 0x75, 0x6e, 0x74, 0x69, 0x6c, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79,
    0x20, 0x4b, 0x75, 0x64, 0x75, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x61, 0x67, 0x72,
    0x65, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x72, 0x61,
    0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x70, 0x61, 0x73, 0x74, 0x2e, 0x0a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x63, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6f, 0x62, 0x6c, 0x69,
    0x67, 0x61, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64,
    0x20, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72,
    0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x20,
    0x62, 0x61, 0x63, 0x6b, 0x2d, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x2e, 0x0a, 0x0a,
    0x20, 0x57, 0x41, 0x52, 0x4e, 0x49, 0x4e, 0x47, 0x3a, 0x20, 0x44, 0x65, 0x70, 0x65, 0x6e, 0x64,
    0x69, 0x6e, 0x67, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x6f, 0x63, 0x6b,
    0x20, 0x73, 0x79, 0x6e, 0x63, 0x68, 0x72, 0x6f, 0x6e, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x74,
    0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x0a, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x61,
    0x79, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x79, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x72,
    0x61, 0x62, 0x6c, 0x65, 0x20, 0x6c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x2e, 0x20, 0x4d, 0x6f,
    0x72, 0x65, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x0a, 0x20, 0x43, 0x4f, 0x4d, 0x4d, 0x49, 0x54, 0x5f, 0x57,
    0x41, 0x49, 0x54, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x65, 0x78,
    0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e,
    0x63, 0x79, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6f, 0x75, 0x74, 0x72, 0x69, 0x67, 0x68, 0x74,
    0x20, 0x66, 0x61, 0x69, 0x6c, 0x20, 0x69, 0x66, 0x0a, 0x20, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x74,
    0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x20, 0x61, 0x72,
    0x65, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x75, 0x6e, 0x73, 0x79, 0x6e, 0x63, 0x68,
    0x72, 0x6f, 0x6e, 0x69, 0x7a, 0x65, 0x64, 0x20, 0x6f, 0x72, 0x20, 0x73, 0x79, 0x6e, 0x63, 0x68,
    0x72, 0x6f, 0x6e, 0x69, 0x7a, 0x65, 0x64, 0x20, 0x62, 0x75, 0x74, 0x0a, 0x20, 0x77, 0x69, 0x74,
    0x68, 0x20, 0x61, 0x20, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x20, 0x65, 0x72, 0x72, 0x6f,
    0x72, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x73, 0x75, 0x72, 0x70, 0x61, 0x73, 0x73, 0x65,
    0x73, 0x20, 0x61, 0x20, 0x70, 0x72, 0x65, 0x2d, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72,
    0x65, 0x64, 0x20, 0x6f, 0x6e, 0x65, 0x2e, 0x0a, 0x0a, 0x20, 0x45, 0x78, 0x61, 0x6d, 0x70, 0x6c,
    0x65, 0x3a, 0x0a, 0x20, 0x2d, 0x20, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x41, 0x20, 0x65,
    0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x73, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x20, 0x58, 0x20, 0x69, 0x6e, 0x20, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x74, 0x20, 0x41, 0x0a,
    0x20, 0x2d, 0x20, 0x41, 0x66, 0x74, 0x65, 0x72, 0x77, 0x61, 0x72, 0x64, 0x73, 0x2c, 0x20, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x41, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x73,
    0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x59, 0x20, 0x69, 0x6e, 0x20,
    0x54, 0x61, 0x62, 0x6c, 0x65, 0x74, 0x20, 0x42, 0x0a, 0x0a, 0x0a, 0x20, 0x43, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x20, 0x42, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x6f, 0x62, 0x73, 0x65, 0x72, 0x76, 0x65,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6f, 0x6c, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x20, 0x6f,
    0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63,
    0x65, 0x73, 0x3a, 0x0a, 0x20, 0x7b, 0x7d, 0x2c, 0x20, 0x7b, 0x58, 0x7d, 0x2c, 0x20, 0x7b, 0x58,
    0x20, 0x59, 0x7d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x02, 0x01, 0x12, 0x04, 0x98,
    0x01, 0x02, 0x0d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x02, 0x02, 0x12, 0x04, 0x98, 0x01,
    0x10, 0x11, 0x0a, 0xa8, 0x04, 0x0a, 0x02, 0x05, 0x04, 0x12, 0x06, 0xa5, 0x01, 0x00, 0xc7, 0x01,
    0x01, 0x1a, 0x99, 0x04, 0x20, 0x54, 0x68, 0x65, 0x20, 0x70, 0x6f, 0x73, 0x73, 0x69, 0x62, 0x6c,
    0x65, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x73, 0x20, 0x66, 0x6f, 0x72,
    0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x0a, 0x20, 0x43, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 0x69, 0x6e, 0x20,
    0x53, 0x63, 0x61, 0x6e, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x2e, 0x0a, 0x20,
    0x54, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x6b, 0x65, 0x65, 0x70, 0x73,
    0x20, 0x32, 0x20, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x20, 0x62, 0x6f, 0x75, 0x6e,
    0x64, 0x61, 0x72, 0x69, 0x65, 0x73, 0x3a, 0x0a, 0x20, 0x2d, 0x20, 0x54, 0x68, 0x65, 0x20, 0x65,
    0x61, 0x72, 0x6c, 0x69, 0x65, 0x73, 0x74, 0x20, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74,
    0x3a, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x63, 0x6f, 0x72, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    0x64, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x61, 0x72, 0x6c, 0x69, 0x65,
    0x73, 0x74, 0x20, 0x6b, 0x65, 0x70, 0x74, 0x20, 0x75, 0x6e, 0x64, 0x6f, 0x20, 0x72, 0x65, 0x63,
    0x6f, 0x72, 0x64, 0x73, 0x0a, 0x20, 0x20, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74,
    0x61, 0x62, 0x6c, 0x65, 0x74, 0x2c, 0x20, 0x6d, 0x65, 0x61, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65,
    0x20, 0x28, 0x42, 0x61, 0x73, 0x65, 0x29, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x75,
    0x6e, 0x64, 0x6f, 0x6e, 0x65, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x20, 0x20, 0x74,
    0x68, 0x69, 0x73, 0x20, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x2e, 0x0a, 0x20, 0x2d,
    0x20, 0x54, 0x68, 0x65, 0x20, 0x6c, 0x61, 0x74, 0x65, 0x73, 0x74, 0x20, 0x73, 0x6e, 0x61, 0x70,
    0x73, 0x68, 0x6f, 0x74, 0x3a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x63, 0x6f, 0x72, 0x72, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x64, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6e,
    0x73, 0x74, 0x61, 0x6e, 0x74, 0x20, 0x62, 0x65, 0x79, 0x6f, 0x6e, 0x64, 0x20, 0x77, 0x68, 0x69,
    0x63, 0x68, 0x20, 0x6e, 0x6f, 0x0a, 0x20, 0x20, 0x20, 0x6e, 0x6f, 0x20, 0x74, 0x72, 0x61, 0x6e,
    0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x68, 0x61, 0x76,
    0x65, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x61, 0x72, 0x6c, 0x69, 0x65, 0x72, 0x20, 0x74, 0x69, 0x6d,
    0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x20, 0x55, 0x73, 0x75, 0x61, 0x6c, 0x6c, 0x79, 0x20,
    0x74, 0x68, 0x69, 0x73, 0x20, 0x63, 0x6f, 0x72, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x64, 0x73,
    0x0a, 0x20, 0x20, 0x20, 0x74, 0x6f, 0x20, 0x77, 0x68, 0x61, 0x74, 0x65, 0x76, 0x65, 0x72, 0x20,
    0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x2d, 0x3e, 0x4e, 0x6f, 0x77, 0x28, 0x29, 0x20, 0x72, 0x65, 0x74,
    0x75, 0x72, 0x6e, 0x73, 0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65,
    0x20, 0x68, 0x69, 0x67, 0x68, 0x65, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x70, 0x72, 0x6f, 0x70, 0x61, 0x67, 0x61, 0x74, 0x65, 0x73,
    0x0a, 0x20, 0x20, 0x20, 0x61, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x20,
    0x28, 0x73, 0x65, 0x65, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x77, 0x29, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a,
    0x03, 0x05, 0x04, 0x01, 0x12, 0x04, 0xa5, 0x01, 0x05, 0x0d, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x04,
    0x02, 0x00, 0x12, 0x04, 0xa6, 0x01, 0x02, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xa6, 0x01, 0x02, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x00, 0x02,
    0x12, 0x04, 0xa6, 0x01, 0x16, 0x17, 0x0a, 0xad, 0x03, 0x0a, 0x04, 0x05, 0x04, 0x02, 0x01, 0x12,
    0x04, 0xaf, 0x01, 0x02, 0x12, 0x1a, 0x9e, 0x03, 0x20, 0x57, 0x68, 0x65, 0x6e, 0x20, 0x52, 0x45,
    0x41, 0x44, 0x5f, 0x4c, 0x41, 0x54, 0x45, 0x53, 0x54, 0x20, 0x69, 0x73, 0x20, 0x73, 0x70, 0x65,
    0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65,
    0x72, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x69, 0x6e, 0x64, 0x65, 0x70, 0x65, 0x6e, 0x64,
    0x65, 0x6e, 0x74, 0x6c, 0x79, 0x0a, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c,
    0x6f, 0x63, 0x6b, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x61, 0x6c, 0x77,
    0x61, 0x79, 0x73, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x76,
    0x69, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x73, 0x20, 0x61, 0x74,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65,
    0x71, 0x75, 0x65, 0x73, 0x74, 0x0a, 0x20, 0x77, 0x61, 0x73, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69,
    0x76, 0x65, 0x64, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x6f,
    0x66, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x64, 0x6f, 0x65, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20,
    0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x61, 0x20, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f,
    0x74, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x20, 0x73, 0x69, 0x6e, 0x63,
    0x65, 0x0a, 0x20, 0x69, 0x74, 0x20, 0x6d, 0x69, 0x67, 0x68, 0x74, 0x20, 0x6e, 0x6f, 0x74, 0x20,
    0x62, 0x65, 0x20, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x2c, 0x20, 0x69,
    0x2e, 0x65, 0x2e, 0x20, 0x61, 0x20, 0x6c, 0x61, 0x74, 0x65, 0x72, 0x20, 0x72, 0x65, 0x61, 0x64,
    0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x64, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x0a, 0x20,
    0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x20, 0x6d, 0x69, 0x67, 0x68, 0x74, 0x20,
    0x79, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x72, 0x6f, 0x77, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20,
    0x77, 0x65, 0x72, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x64, 0x20, 0x62,
    0x79, 0x20, 0x69, 0x6e, 0x2d, 0x66, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x20, 0x74, 0x72, 0x61, 0x6e,
    0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x0a, 0x0a, 0x20, 0x54, 0x68, 0x69, 0x73,
    0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20,
    0x6d, 0x6f, 0x64, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xaf, 0x01, 0x02, 0x0d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x01, 0x02, 0x12, 0x04,
    0xaf, 0x01, 0x10, 0x11, 0x0a, 0xf2, 0x0a, 0x0a, 0x04, 0x05, 0x04, 0x02, 0x02, 0x12, 0x04, 0xc6,
    0x01, 0x02, 0x17, 0x1a, 0xe3, 0x0a, 0x20, 0x57, 0x68, 0x65, 0x6e, 0x20, 0x52, 0x45, 0x41, 0x44,
    0x5f, 0x41, 0x54, 0x5f, 0x53, 0x4e, 0x41, 0x50, 0x53, 0x48, 0x4f, 0x54, 0x20, 0x69, 0x73, 0x20,
    0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65,
    0x72, 0x76, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70,
    0x74, 0x20, 0x74, 0x6f, 0x20, 0x70, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x20, 0x61, 0x20, 0x72,
    0x65, 0x61, 0x64, 0x0a, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75,
    0x69, 0x72, 0x65, 0x64, 0x20, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x2e, 0x20, 0x49,
    0x66, 0x20, 0x6e, 0x6f, 0x20, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x20, 0x69, 0x73,
    0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72,
    0x76, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x74, 0x61, 0x6b, 0x65, 0x20, 0x74, 0x68,
    0x65, 0x0a, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20,
    0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x20,
    0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x20, 0x53, 0x6e, 0x61, 0x70, 0x73,
    0x68, 0x6f, 0x74, 0x20, 0x72, 0x65, 0x61, 0x64, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65,
    0x70, 0x65, 0x61, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x2c, 0x20, 0x69, 0x2e, 0x65, 0x2e, 0x0a, 0x20,
    0x61, 0x6c, 0x6c, 0x20, 0x66, 0x75, 0x74, 0x75, 0x72, 0x65, 0x20, 0x72, 0x65, 0x61, 0x64, 0x73,
    0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x74, 0x69, 0x6d,
    0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x79, 0x69, 0x65, 0x6c,
    0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x72, 0x6f, 0x77, 0x73, 0x2e,
    0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x70, 0x65, 0x72, 0x66, 0x6f, 0x72,
    0x6d, 0x65, 0x64, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x70, 0x65, 0x6e,
    0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x77, 0x61, 0x69, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x66, 0x6f,
    0x72, 0x20, 0x69, 0x6e, 0x2d, 0x66, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x20, 0x74, 0x72, 0x61, 0x6e,
    0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x77, 0x68, 0x6f, 0x73, 0x65, 0x20, 0x74,
    0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x0a, 0x20, 0x69, 0x73, 0x20, 0x6c, 0x6f, 0x77,
    0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6e, 0x61, 0x70,
    0x73, 0x68, 0x6f, 0x74, 0x27, 0x73, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
    0x20, 0x74, 0x6f, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x2e, 0x0a, 0x0a, 0x20,
    0x57, 0x68, 0x65, 0x6e, 0x20, 0x6d, 0x69, 0x78, 0x69, 0x6e, 0x67, 0x20, 0x72, 0x65, 0x61, 0x64,
    0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x73, 0x20, 0x63, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66,
    0x79, 0x20, 0x43, 0x4f, 0x4d, 0x4d, 0x49, 0x54, 0x5f, 0x57, 0x41, 0x49, 0x54, 0x20, 0x61, 0x73,
    0x20, 0x74, 0x68, 0x65, 0x69, 0x72, 0x0a, 0x20, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c,
    0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x20, 0x6d, 0x6f, 0x64,
    0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x75, 0x73, 0x65, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x77, 0x72, 0x69, 0x74,
    0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x20, 0x74, 0x6f, 0x0a, 0x20,
    0x74, 0x6f, 0x20, 0x70, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x20, 0x73, 0x6e, 0x61, 0x70, 0x73,
    0x68, 0x6f, 0x74, 0x20, 0x72, 0x65, 0x61, 0x64, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x67, 0x75,
    0x61, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x65, 0x64, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68,
    0x61, 0x74, 0x20, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x20, 0x74, 0x69, 0x6d, 0x65,
    0x20, 0x69, 0x73, 0x0a, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x72, 0x65, 0x64, 0x20,
    0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x73, 0x74, 0x20, 0x62, 0x79, 0x20, 0x61,
    0x6c, 0x6c, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e,
    0x6f, 0x20, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20, 0x61, 0x63, 0x74,
    0x69, 0x6f, 0x6e, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x6e, 0x65, 0x63, 0x65, 0x73, 0x73, 0x61, 0x72,
    0x79, 0x2e, 0x20, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x75, 0x73, 0x69, 0x6e, 0x67,
    0x20, 0x43, 0x4c, 0x49, 0x45, 0x4e, 0x54, 0x5f, 0x50, 0x52, 0x4f, 0x50, 0x41, 0x47, 0x41, 0x54,
    0x45, 0x44, 0x20, 0x68, 0x6f, 0x77, 0x65, 0x76, 0x65, 0x72, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20,
    0x66, 0x6f, 0x72, 0x63, 0x69, 0x62, 0x6c, 0x79, 0x20, 0x70, 0x72, 0x6f, 0x70, 0x61, 0x67, 0x61,
    0x74, 0x65, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
    0x70, 0x73, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x20, 0x61, 0x74, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20,
    0x74, 0x69, 0x6d, 0x65, 0x2c, 0x20, 0x73, 0x6f, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f,
    0x74, 0x20, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x0a, 0x20, 0x61, 0x6e, 0x79, 0x20,
    0x6d, 0x6f, 0x72, 0x65, 0x20, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e,
    0x73, 0x20, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6e, 0x61,
    0x70, 0x73, 0x68, 0x6f, 0x74, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20,
    0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x20,
    0x54, 0x68, 0x65, 0x20, 0x6c, 0x61, 0x74, 0x74, 0x65, 0x72, 0x20, 0x6f, 0x70, 0x74, 0x69, 0x6f,
    0x6e, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x65, 0x64,
    0x20, 0x62, 0x79, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69,
    0x66, 0x79, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x6f, 0x72, 0x0a, 0x20, 0x74, 0x77, 0x6f, 0x20, 0x74,
    0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x73, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66,
    0x69, 0x72, 0x73, 0x74, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x6f, 0x62, 0x74, 0x61, 0x69, 0x6e, 0x65,
    0x64, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x65, 0x76, 0x69,
    0x6f, 0x75, 0x73, 0x20, 0x43, 0x4c, 0x49, 0x45, 0x4e, 0x54, 0x5f, 0x50, 0x52, 0x4f, 0x50, 0x41,
    0x47, 0x41, 0x54, 0x45, 0x44, 0x0a, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x2c, 0x20, 0x64, 0x69,
    0x72, 0x65, 0x63, 0x74, 0x6c, 0x79, 0x20, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67,
    0x68, 0x20, 0x62, 0x61, 0x63, 0x6b, 0x2d, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x2c,
    0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x20,
    0x61, 0x6e, 0x64, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x0a, 0x20, 0x63, 0x68, 0x65,
    0x63, 0x6b, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76,
    0x65, 0x72, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x20, 0x6f,
    0x6e, 0x65, 0x2c, 0x20, 0x69, 0x66, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x2c, 0x20,
    0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x63, 0x74, 0x75, 0x61, 0x6c, 0x20, 0x73, 0x6e,
    0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x0a, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x74, 0x69, 0x6d,
    0x65, 0x2e, 0x20, 0x57, 0x68, 0x65, 0x6e, 0x20, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6e,
    0x67, 0x20, 0x62, 0x6f, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x61, 0x74, 0x74, 0x65,
    0x72, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x20,
    0x74, 0x68, 0x61, 0x6e, 0x20, 0x6f, 0x72, 0x20, 0x65, 0x71, 0x75, 0x61, 0x6c, 0x20, 0x74, 0x6f,
    0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x65, 0x72, 0x2e, 0x0a, 0x20, 0x54,
    0x4f, 0x44, 0x4f, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x61, 0x63,
    0x74, 0x75, 0x61, 0x6c, 0x6c, 0x79, 0x20, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x70, 0x61, 0x67, 0x61, 0x74, 0x65, 0x64, 0x20, 0x74, 0x69,
    0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02,
    0x02, 0x01, 0x12, 0x04, 0xc6, 0x01, 0x02, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x02,
    0x02, 0x12, 0x04, 0xc6, 0x01, 0x15, 0x16, 0x0a, 0xb4, 0x02, 0x0a, 0x02, 0x05, 0x05, 0x12, 0x06,
    0xce, 0x01, 0x00, 0xd3, 0x01, 0x01, 0x1a, 0xa5, 0x02, 0x20, 0x54, 0x68, 0x65, 0x20, 0x70, 0x6f,
    0x73, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x20, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x20, 0x6d, 0x6f, 0x64,
    0x65, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x0a,
    0x20, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x79,
    0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x6e, 0x65, 0x77, 0x20, 0x73, 0x63,
    0x61, 0x6e, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x2e, 0x0a, 0x20, 0x4f, 0x72,
    0x64, 0x65, 0x72, 0x65, 0x64, 0x20, 0x73, 0x63, 0x61, 0x6e, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20,
    0x66, 0x61, 0x75, 0x6c, 0x74, 0x2d, 0x74, 0x6f, 0x6c, 0x65, 0x72, 0x61, 0x6e, 0x74, 0x2c, 0x20,
    0x61, 0x6e, 0x64, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x74, 0x72, 0x69,
    0x65, 0x64, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x6e, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x63, 0x61, 0x73, 0x65, 0x0a, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x61, 0x62,
    0x6c, 0x65, 0x74, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x75,
    0x72, 0x65, 0x2e, 0x20, 0x48, 0x6f, 0x77, 0x65, 0x76, 0x65, 0x72, 0x2c, 0x20, 0x6f, 0x72, 0x64,
    0x65, 0x72, 0x65, 0x64, 0x20, 0x73, 0x63, 0x61, 0x6e, 0x73, 0x20, 0x69, 0x6d, 0x70, 0x6f, 0x73,
    0x65, 0x20, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20, 0x6f, 0x76, 0x65,
    0x72, 0x68, 0x65, 0x61, 0x64, 0x0a, 0x20, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x74, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x6e,
    0x65, 0x65, 0x64, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x6f, 0x72, 0x74, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x20, 0x72, 0x6f, 0x77, 0x73, 0x2e, 0x0a, 0x0a, 0x0b,
    0x0a, 0x03, 0x05, 0x05, 0x01, 0x12, 0x04, 0xce, 0x01, 0x05, 0x0e, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x05, 0x02, 0x00, 0x12, 0x04, 0xcf, 0x01, 0x02, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x05, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xcf, 0x01, 0x02, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x05, 0x02, 0x00,
    0x02, 0x12, 0x04, 0xcf, 0x01, 0x17, 0x18, 0x0a, 0x2f, 0x0a, 0x04, 0x05, 0x05, 0x02, 0x01, 0x12,
    0x04, 0xd1, 0x01, 0x02, 0x10, 0x1a, 0x21, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x6f, 0x72, 0x64, 0x65,
    0x72, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x05, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xd1, 0x01, 0x02, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x05, 0x02, 0x01, 0x02,
    0x12, 0x04, 0xd1, 0x01, 0x0e, 0x0f, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x05, 0x02, 0x02, 0x12, 0x04,
    0xd2, 0x01, 0x02, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x05, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd2,
    0x01, 0x02, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x05, 0x02, 0x02, 0x02, 0x12, 0x04, 0xd2, 0x01,
    0x0c, 0x0d, 0x0a, 0x47, 0x0a, 0x02, 0x04, 0x03, 0x12, 0x06, 0xd6, 0x01, 0x00, 0x82, 0x02, 0x01,
    0x1a, 0x39, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x65,
    0x64, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x20, 0x4b, 0x75,
    0x64, 0x75, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69,
    0x6f, 0x6e, 0x20, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x03, 0x01, 0x12, 0x04, 0xd6, 0x01, 0x08, 0x19, 0x0a, 0xf2, 0x01, 0x0a, 0x04, 0x04, 0x03, 0x03,
    0x00, 0x12, 0x06, 0xdb, 0x01, 0x02, 0xe0, 0x01, 0x03, 0x1a, 0xe1, 0x01, 0x20, 0x41, 0x20, 0x63,
    0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x20, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72,
    0x20, 0x66, 0x6f, 0x72, 0x20, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x73,
    0x63, 0x68, 0x65, 0x6d, 0x61, 0x73, 0x2e, 0x20, 0x49, 0x6e, 0x20, 0x67, 0x65, 0x6e, 0x65, 0x72,
    0x61, 0x6c, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x77, 0x69, 0x6c,
    0x6c, 0x20, 0x62, 0x65, 0x0a, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20,
    0x61, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x73, 0x69, 0x6e, 0x63, 0x65,
    0x20, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x20, 0x49, 0x44, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20,
    0x61, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x0a,
    0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x2e, 0x20, 0x41, 0x6c, 0x6c, 0x20, 0x6f, 0x74, 0x68,
    0x65, 0x72, 0x20, 0x75, 0x73, 0x65, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x70, 0x61, 0x72, 0x74, 0x69,
    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x73, 0x20, 0x77, 0x69, 0x6c,
    0x6c, 0x20, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x75, 0x6d, 0x65, 0x72, 0x69,
    0x63, 0x20, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x20, 0x49, 0x44, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x03, 0x03, 0x00, 0x01, 0x12, 0x04, 0xdb, 0x01, 0x0a, 0x1c, 0x0a, 0x10, 0x0a, 0x06,
    0x04, 0x03, 0x03, 0x00, 0x08, 0x00, 0x12, 0x06, 0xdc, 0x01, 0x04, 0xdf, 0x01, 0x05, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x03, 0x03, 0x00, 0x08, 0x00, 0x01, 0x12, 0x04, 0xdc, 0x01, 0x0a, 0x14, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x03, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xdd, 0x01, 0x06, 0x13, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xdd, 0x01, 0x06, 0x0b,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdd, 0x01, 0x0c,
    0x0e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xdd, 0x01,
    0x11, 0x12, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x03, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xde, 0x01,
    0x06, 0x16, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xde,
    0x01, 0x06, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xde, 0x01, 0x0d, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xde, 0x01, 0x14, 0x15, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x03, 0x03, 0x01, 0x12, 0x06, 0xe2,
    0x01, 0x02, 0xe6, 0x01, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x03, 0x01, 0x01, 0x12, 0x04,
    0xe2, 0x01, 0x0a, 0x17, 0x0a, 0x7b, 0x0a, 0x06, 0x04, 0x03, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04,
    0xe5, 0x01, 0x04, 0x2c, 0x1a, 0x6b, 0x20, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x20, 0x69, 0x64,
    0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x63, 0x6f, 0x6c,
    0x75, 0x6d, 0x6e, 0x73, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x64, 0x20, 0x69, 0x6e,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x2e, 0x20, 0x41, 0x6c, 0x6c, 0x20,
    0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x73, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x0a,
    0x20, 0x61, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x20, 0x6b, 0x65, 0x79, 0x2e,
    0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe5, 0x01,
    0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x01, 0x02, 0x00, 0x06, 0x12, 0x04, 0xe5,
    0x01, 0x0d, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xe5, 0x01, 0x20, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xe5, 0x01, 0x2a, 0x2b, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x03, 0x03, 0x02, 0x12, 0x06, 0xe8,
    0x01, 0x02, 0xfe, 0x01, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x03, 0x02, 0x01, 0x12, 0x04,
    0xe8, 0x01, 0x0a, 0x1c, 0x0a, 0x7b, 0x0a, 0x06, 0x04, 0x03, 0x03, 0x02, 0x02, 0x00, 0x12, 0x04,
    0xeb, 0x01, 0x04, 0x2c, 0x1a, 0x6b, 0x20, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x20, 0x69, 0x64,
    0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x63, 0x6f, 0x6c,
    0x75, 0x6d, 0x6e, 0x73, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x64, 0x20, 0x69, 0x6e,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x61, 0x73, 0x68, 0x2e, 0x20, 0x45, 0x76, 0x65, 0x72, 0x79,
    0x20, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x0a,
    0x20, 0x61, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x20, 0x6b, 0x65, 0x79, 0x2e,
    0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x02, 0x02, 0x00, 0x04, 0x12, 0x04, 0xeb, 0x01,
    0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x02, 0x02, 0x00, 0x06, 0x12, 0x04, 0xeb,
    0x01, 0x0d, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x02, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xeb, 0x01, 0x20, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x02, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xeb, 0x01, 0x2a, 0x2b, 0x0a, 0x5a, 0x0a, 0x06, 0x04, 0x03, 0x03, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xee, 0x01, 0x04, 0x23, 0x1a, 0x4a, 0x20, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f,
    0x66, 0x20, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x20, 0x69, 0x6e, 0x74, 0x6f, 0x20, 0x77,
    0x68, 0x69, 0x63, 0x68, 0x20, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x73, 0x20, 0x77, 0x69, 0x6c,
    0x6c, 0x20, 0x62, 0x65, 0x20, 0x68, 0x61, 0x73, 0x68, 0x65, 0x64, 0x2e, 0x20, 0x4d, 0x75, 0x73,
    0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x74, 0x20, 0x6c, 0x65, 0x61, 0x73, 0x74, 0x20, 0x32, 0x2e,
    0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x02, 0x02, 0x01, 0x04, 0x12, 0x04, 0xee, 0x01,
    0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x02, 0x02, 0x01, 0x05, 0x12, 0x04, 0xee,
    0x01, 0x0d, 0x12, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x02, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xee, 0x01, 0x13, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x02, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xee, 0x01, 0x21, 0x22, 0x0a, 0xb4, 0x02, 0x0a, 0x06, 0x04, 0x03, 0x03, 0x02, 0x02, 0x02,
    0x12, 0x04, 0xf5, 0x01, 0x04, 0x1d, 0x1a, 0xa3, 0x02, 0x20, 0x53, 0x65, 0x65, 0x64, 0x20, 0x76,
    0x61, 0x6c, 0x75, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x63, 0x61,
    0x6c, 0x63, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x20, 0x41, 0x64, 0x6d, 0x69, 0x6e,
    0x69, 0x73, 0x74, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x73, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x73, 0x65,
    0x74, 0x20, 0x61, 0x20, 0x73, 0x65, 0x65, 0x64, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x0a, 0x20,
    0x6f, 0x6e, 0x20, 0x61, 0x20, 0x70, 0x65, 0x72, 0x2d, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x62,
    0x61, 0x73, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x20, 0x74, 0x6f,
    0x20, 0x72, 0x61, 0x6e, 0x64, 0x6f, 0x6d, 0x69, 0x7a, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d,
    0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x66, 0x20, 0x72, 0x6f, 0x77, 0x73, 0x20, 0x74,
    0x6f, 0x0a, 0x20, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x2e, 0x20, 0x53, 0x65, 0x74, 0x74,
    0x69, 0x6e, 0x67, 0x20, 0x61, 0x20, 0x73, 0x65, 0x65, 0x64, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69,
    0x64, 0x65, 0x73, 0x20, 0x73, 0x6f, 0x6d, 0x65, 0x20, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x20,
    0x6f, 0x66, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x67,
    0x61, 0x69, 0x6e, 0x73, 0x74, 0x20, 0x64, 0x65, 0x6e, 0x69, 0x61, 0x6c, 0x0a, 0x20, 0x6f, 0x66,
    0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x61, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x73,
    0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x62,
    0x75, 0x63, 0x6b, 0x65, 0x74, 0x20, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x73, 0x20, 0x63, 0x6f,
    0x6e, 0x74, 0x61, 0x69, 0x6e, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69,
    0x64, 0x65, 0x64, 0x0a, 0x20, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x03, 0x03, 0x02, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf5, 0x01, 0x04, 0x0c, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x03, 0x03, 0x02, 0x02, 0x02, 0x05, 0x12, 0x04, 0xf5, 0x01, 0x0d, 0x13, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x03, 0x03, 0x02, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf5, 0x01, 0x14, 0x18, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x02, 0x02, 0x02, 0x03, 0x12, 0x04, 0xf5, 0x01, 0x1b, 0x1c,
    0x0a, 0x10, 0x0a, 0x06, 0x04, 0x03, 0x03, 0x02, 0x04, 0x00, 0x12, 0x06, 0xf7, 0x01, 0x04, 0xfa,
    0x01, 0x05, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x02, 0x04, 0x00, 0x01, 0x12, 0x04, 0xf7,
    0x01, 0x09, 0x16, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x03, 0x03, 0x02, 0x04, 0x00, 0x02, 0x00, 0x12,
    0x04, 0xf8, 0x01, 0x06, 0x12, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x03, 0x03, 0x02, 0x04, 0x00, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xf8, 0x01, 0x06, 0x0d, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x03, 0x03, 0x02,
    0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xf8, 0x01, 0x10, 0x11, 0x0a, 0x10, 0x0a, 0x08, 0x04,
    0x03, 0x03, 0x02, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xf9, 0x01, 0x06, 0x18, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x03, 0x03, 0x02, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf9, 0x01, 0x06, 0x13,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x03, 0x03, 0x02, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xf9,
    0x01, 0x16, 0x17, 0x0a, 0x4c, 0x0a, 0x06, 0x04, 0x03, 0x03, 0x02, 0x02, 0x03, 0x12, 0x04, 0xfd,
    0x01, 0x04, 0x2e, 0x1a, 0x3c, 0x20, 0x54, 0x68, 0x65, 0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x61,
    0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x20, 0x74, 0x6f, 0x20, 0x75, 0x73, 0x65, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x63, 0x61, 0x6c, 0x63, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x2e,
    0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x02, 0x02, 0x03, 0x04, 0x12, 0x04, 0xfd, 0x01,
    0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x02, 0x02, 0x03, 0x06, 0x12, 0x04, 0xfd,
    0x01, 0x0d, 0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x02, 0x02, 0x03, 0x01, 0x12, 0x04,
    0xfd, 0x01, 0x1b, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x03, 0x03, 0x02, 0x02, 0x03, 0x03, 0x12,
    0x04, 0xfd, 0x01, 0x2c, 0x2d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x00, 0x12, 0x04, 0x80,
    0x02, 0x02, 0x36, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x04, 0x12, 0x04, 0x80, 0x02,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x06, 0x12, 0x04, 0x80, 0x02, 0x0b,
    0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x01, 0x12, 0x04, 0x80, 0x02, 0x1e, 0x31,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x03, 0x12, 0x04, 0x80, 0x02, 0x34, 0x35, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x01, 0x12, 0x04, 0x81, 0x02, 0x02, 0x2a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x03, 0x02, 0x01, 0x04, 0x12, 0x04, 0x81, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x03, 0x02, 0x01, 0x06, 0x12, 0x04, 0x81, 0x02, 0x0b, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x03, 0x02, 0x01, 0x01, 0x12, 0x04, 0x81, 0x02, 0x19, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03,
    0x02, 0x01, 0x03, 0x12, 0x04, 0x81, 0x02, 0x28, 0x29, 0x0a, 0x40, 0x0a, 0x02, 0x04, 0x04, 0x12,
    0x06, 0x85, 0x02, 0x00, 0x8d, 0x02, 0x01, 0x1a, 0x32, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x65,
    0x72, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20,
    0x6f, 0x66, 0x20, 0x61, 0x20, 0x4b, 0x75, 0x64, 0x75, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20,
    0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x04, 0x01, 0x12, 0x04, 0x85, 0x02, 0x08, 0x13, 0x0a, 0x9a, 0x01, 0x0a, 0x04, 0x04, 0x04, 0x02,
    0x00, 0x12, 0x04, 0x88, 0x02, 0x02, 0x32, 0x1a, 0x8b, 0x01, 0x20, 0x54, 0x68, 0x65, 0x20, 0x68,
    0x61, 0x73, 0x68, 0x20, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x20, 0x54, 0x68,
    0x65, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x68, 0x61, 0x73, 0x68,
    0x20, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x6d, 0x61,
    0x74, 0x63, 0x68, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20,
    0x6f, 0x66, 0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x20, 0x63,
    0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x27, 0x73, 0x20, 0x73, 0x63, 0x68,
    0x65, 0x6d, 0x61, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x04, 0x12, 0x04,
    0x88, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x05, 0x12, 0x04, 0x88,
    0x02, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x01, 0x12, 0x04, 0x88, 0x02,
    0x11, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x03, 0x12, 0x04, 0x88, 0x02, 0x20,
    0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x08, 0x12, 0x04, 0x88, 0x02, 0x22, 0x31,
    0x0a, 0x10, 0x0a, 0x08, 0x04, 0x04, 0x02, 0x00, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x04, 0x88, 0x02,
    0x23, 0x30, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x04, 0x02, 0x00, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12,
    0x04, 0x88, 0x02, 0x23, 0x29, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x04, 0x02, 0x00, 0x08, 0xe7, 0x07,
    0x00, 0x02, 0x00, 0x12, 0x04, 0x88, 0x02, 0x23, 0x29, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x04, 0x02,
    0x00, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x88, 0x02, 0x23, 0x29, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x04, 0x02, 0x00, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x04, 0x88, 0x02, 0x2c,
    0x30, 0x0a, 0x3c, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x01, 0x12, 0x04, 0x8a, 0x02, 0x02, 0x29, 0x1a,
    0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x20, 0x73, 0x74,
    0x61, 0x72, 0x74, 0x20, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6b, 0x65,
    0x79, 0x20, 0x28, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x76, 0x65, 0x29, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8a, 0x02, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x05, 0x12, 0x04, 0x8a, 0x02, 0x0b, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x04, 0x02, 0x01, 0x01, 0x12, 0x04, 0x8a, 0x02, 0x11, 0x24, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x04, 0x02, 0x01, 0x03, 0x12, 0x04, 0x8a, 0x02, 0x27, 0x28, 0x0a, 0x3a, 0x0a, 0x04, 0x04,
    0x04, 0x02, 0x02, 0x12, 0x04, 0x8c, 0x02, 0x02, 0x27, 0x1a, 0x2c, 0x20, 0x54, 0x68, 0x65, 0x20,
    0x65, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x20, 0x65, 0x6e, 0x64, 0x20, 0x70, 0x61, 0x72, 0x74,
    0x69, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6b, 0x65, 0x79, 0x20, 0x28, 0x65, 0x78, 0x63, 0x6c, 0x75,
    0x73, 0x69, 0x76, 0x65, 0x29, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x02, 0x04,
    0x12, 0x04, 0x8c, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x02, 0x05, 0x12,
    0x04, 0x8c, 0x02, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x02, 0x01, 0x12, 0x04,
    0x8c, 0x02, 0x11, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x02, 0x03, 0x12, 0x04, 0x8c,
    0x02, 0x25, 0x26, 0x0a, 0x41, 0x0a, 0x02, 0x04, 0x05, 0x12, 0x06, 0x90, 0x02, 0x00, 0xb4, 0x02,
    0x01, 0x1a, 0x33, 0x20, 0x41, 0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20,
    0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x61, 0x70, 0x70, 0x6c,
    0x69, 0x65, 0x64, 0x20, 0x6f, 0x6e, 0x20, 0x61, 0x20, 0x4b, 0x75, 0x64, 0x75, 0x20, 0x63, 0x6f,
    0x6c, 0x75, 0x6d, 0x6e, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x05, 0x01, 0x12, 0x04, 0x90,
    0x02, 0x08, 0x19, 0x0a, 0x2a, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x00, 0x12, 0x04, 0x92, 0x02, 0x02,
    0x1d, 0x1a, 0x1c, 0x20, 0x54, 0x68, 0x65, 0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74,
    0x65, 0x20, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x04, 0x12, 0x04, 0x92, 0x02, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x05, 0x12, 0x04, 0x92, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x05, 0x02, 0x00, 0x01, 0x12, 0x04, 0x92, 0x02, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x05, 0x02, 0x00, 0x03, 0x12, 0x04, 0x92, 0x02, 0x1b, 0x1c, 0x0a, 0x0e, 0x0a, 0x04, 0x04,
    0x05, 0x03, 0x00, 0x12, 0x06, 0x94, 0x02, 0x02, 0xa5, 0x02, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x05, 0x03, 0x00, 0x01, 0x12, 0x04, 0x94, 0x02, 0x0a, 0x0f, 0x0a, 0x2c, 0x0a, 0x06, 0x04, 0x05,
    0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xa1, 0x02, 0x04, 0x1d, 0x1a, 0x1c, 0x20, 0x54, 0x68, 0x65,
    0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x76, 0x65, 0x20, 0x6c, 0x6f, 0x77, 0x65, 0x72,
    0x20, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x05, 0x03, 0x00,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xa1, 0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x05, 0x03,
    0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa1, 0x02, 0x0d, 0x12, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x05,
    0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa1, 0x02, 0x13, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x05, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa1, 0x02, 0x1b, 0x1c, 0x0a, 0x2c, 0x0a, 0x06,
    0x04, 0x05, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xa4, 0x02, 0x04, 0x1d, 0x1a, 0x1c, 0x20, 0x54,
    0x68, 0x65, 0x20, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x76, 0x65, 0x20, 0x75, 0x70, 0x70,
    0x65, 0x72, 0x20, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x05,
    0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa4, 0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x05, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa4, 0x02, 0x0d, 0x12, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x05, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa4, 0x02, 0x13, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x05, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa4, 0x02, 0x1b, 0x1c, 0x0a, 0x0e,
    0x0a, 0x04, 0x04, 0x05, 0x03, 0x01, 0x12, 0x06, 0xa7, 0x02, 0x02, 0xab, 0x02, 0x03, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x05, 0x03, 0x01, 0x01, 0x12, 0x04, 0xa7, 0x02, 0x0a, 0x12, 0x0a, 0x5d, 0x0a,
    0x06, 0x04, 0x05, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04, 0xaa, 0x02, 0x04, 0x1d, 0x1a, 0x4d, 0x20,
    0x54, 0x68, 0x65, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x76, 0x65, 0x20, 0x6c, 0x6f,
    0x77, 0x65, 0x72, 0x20, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x2e, 0x20, 0x53, 0x65, 0x65, 0x20, 0x63,
    0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x74, 0x65, 0x73, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65,
    0x0a, 0x20, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x05, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xaa, 0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x05, 0x03, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xaa, 0x02, 0x0d, 0x12, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x05, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xaa, 0x02, 0x13, 0x18, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x05, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xaa, 0x02, 0x1b, 0x1c,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x05, 0x03, 0x02, 0x12, 0x04, 0xad, 0x02, 0x02, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x05, 0x03, 0x02, 0x01, 0x12, 0x04, 0xad, 0x02, 0x0a, 0x13, 0x0a, 0x0e, 0x0a,
    0x04, 0x04, 0x05, 0x08, 0x00, 0x12, 0x06, 0xaf, 0x02, 0x02, 0xb3, 0x02, 0x03, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x05, 0x08, 0x00, 0x01, 0x12, 0x04, 0xaf, 0x02, 0x08, 0x11, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x05, 0x02, 0x01, 0x12, 0x04, 0xb0, 0x02, 0x04, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x01, 0x06, 0x12, 0x04, 0xb0, 0x02, 0x04, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xb0, 0x02, 0x0a, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xb0, 0x02, 0x12, 0x13, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x02, 0x12,
    0x04, 0xb1, 0x02, 0x04, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x02, 0x06, 0x12, 0x04,
    0xb1, 0x02, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb1,
    0x02, 0x0d, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x02, 0x03, 0x12, 0x04, 0xb1, 0x02,
    0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x03, 0x12, 0x04, 0xb2, 0x02, 0x04, 0x1e,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x03, 0x06, 0x12, 0x04, 0xb2, 0x02, 0x04, 0x0d, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x03, 0x01, 0x12, 0x04, 0xb2, 0x02, 0x0e, 0x19, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x03, 0x03, 0x12, 0x04, 0xb2, 0x02, 0x1c, 0x1d,
];

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
